unit TestDataObjects;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  DUnitX.TestFramework, DUnitX.DUnitCompatibility, Generics.collections, classes, DataObjects2, SysUtils, VarInt,
  StreamCache, DateUtils, contnrs, math;

type

  TestVarInts = class(TTestCase)
  published
    procedure TestVarInt64;
    procedure TestVarInt32;
  end;

  // Test methods for class TDataObj
  TestTDataObj = class(TTestCase)
  strict private
    FDataObj: TDataObj;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestClear;
    procedure TestClearData;
    procedure TestClearAttributes;
    procedure TestPrintToString;
    procedure TestWriteToStream;
    procedure TestReadFromStream;
    procedure TestDataTypeIsAContainer;
    procedure TestCopyFrom;
    procedure TestSettingATag;
  end;
  // Test methods for class TDataGUID

  TestTDataGUID = class(TTestCase)
  strict private
    FDataGUID: TDataGUID;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  end;
  // Test methods for class TDataObjectID

  TestTDataObjectID = class(TTestCase)
  strict private
    FDataObjectID: TDataObjectID;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  end;
  // Test methods for class TDataFrame

  TestTDataFrame = class(TTestCase)
  strict private
    FDataObj: TDataObj;
    FDataFrame: TDataFrame;  // reference, not owned.
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestFindSlot;
    procedure TestNewSlot;
    procedure TestSlotByName;
    procedure TestDeleteSlot;
    procedure TestDelete;
    procedure TestSlotname;
    procedure TestCount;
    procedure TestClear;
    procedure TestCopyFrom;
  end;
  // Test methods for class TDataArray

  TestTDataArray = class(TTestCase)
  strict private
    FDataArray: TDataArray;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestNewSlot;
    procedure TestFind;
    procedure TestForEach;
    procedure TestEvery;
    procedure TestIndexOf;
    procedure TestLastIndexOf;
    procedure TestRemoveForEach;
    procedure TestReduce;
    procedure TestMap;
    procedure TestConcat;
    procedure TestAppendFrom;
  end;
  // Test methods for class TDataSparseArray

  TestTDataSparseArray = class(TTestCase)
  const
    cTestSet: array[0..12] of int64 = (1, 10, 100, 1000, 10000, 100000, $7FFFFFFFFFFFFFFF, -1, -10, -100, -1000, -10000, -100000);
  strict private
    FDataObj: TDataObj;
    fSparseArray: TDataSparseArray;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestFindSlot;
    procedure TestNewSlot;
    procedure TestSlotByIndex;
    procedure TestDeleteSlot;
    procedure TestSlotIndex;
    procedure TestClear;
    procedure TestCopyFrom;
  end;
  // Test methods for class TDataAttributeStore


implementation

procedure MakeTestObject(aObj: TDataObj);
var
  i: integer;
  lGUID: TGUID;
  lbuffer: array[0..23] of byte;  // NOTE: that UBJSON does not like serializing binary data... very inefficient, but some of the other serialzations are more binary friendly.
  lDT: TDateTime;
  j: int64;
  lVal: int64;
begin
  lDT := EncodeDateTime(2025,1,2,3,4,5,6);
  with aObj.AsFrame do
  begin
    newSlot('Boolean').AsBoolean := true;
    newSlot('Byte').AsByte := 123;
    newSlot('Int32').AsInt32 := 12345;
    newSlot('Int64').AsInt64 := 123456789;
    newSlot('Single').AsSingle := 12345.6789;
    newSlot('Double').AsDouble := 98765.4321;
    newSlot('DateTime').AsDateTime := lDT;
    newSlot('UTCDateTime').AsUTCDateTime := DateTimeToUnix(lDT);
    newSlot('Date').AsDate := lDT;
    newSlot('Time').AsTime := lDT;

    lGUID.D1 := $FEDCBA09;
    lGUID.D2 := $1234;
    lGUID.D3 := $4321;
    lGUID.D4[0] := 9;
    lGUID.D4[1] := 8;
    lGUID.D4[2] := 7;
    lGUID.D4[3] := 6;
    lGUID.D4[4] := 5;
    lGUID.D4[5] := 4;
    lGUID.D4[6] := 3;
    lGUID.D4[7] := 2;
    newSlot('GUID').AsGUID.GUID := lGUID;

    with newSlot('ObjectId').AsObjectID do
    begin
      for i := 0 to 11 do
        Data[i] := i;
    end;

    newSlot('String').AsString := 'Hello World';
    newSlot('Symbol').AsSymbol := 'SYMBOL';
    with newSlot('StringList').AsStringList do
    begin
      Add('JSON (JavaScript Object Notation) is a lightweight data-interchange format.');
      Add('It is easy for humans to read and write.');
      Add('It is easy for machines to parse and generate.');
      Add('It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.');
      Add('JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others.');
      Add('These properties make JSON an ideal data-interchange language.');
    end;
    with newSlot('Frame').AsFrame do
    begin
      NewSlot('FirstName').AsString := 'Sean';
      Newslot('LastName').AsString := 'Solberg';
    end;

    with newSlot('Array').AsArray do
    begin
      for i := 0 to 19 do
        newSlot.AsInt32 := i*5;
    end;

    with newSlot('SparseArray').AsSparseArray do
    begin
      for j := 0 to 63 do
      begin
        lVal := int64(1) shl j;
        newSlot(lVal).AsString := 'Key '+IntToStr(lVal)+' is 1 shifted by '+IntToStr(j);
      end;
    end;

    for i := low(lbuffer) to high(lbuffer) do
      lBuffer[i] := i;

    newSlot('Binary').AsBinary.Write(lbuffer, sizeof(lbuffer));

    // This is showing the ability to create a dataObject that is a TAG.  That tag then has a TagValue and an internal DataObj that can be set to anything.
    // This is mostly a feature to support Tags in CBOR.   See the CBOR streamer for details.
    with newSlot('tag').AsTag do
    begin
      TagValue := 32;
      DataObj.AsString := 'http://dataobjectspec.org';
    end;
  end;
end;

// NOTE:  If the code above changes at all in producing sample data, then the code below must be reproduced to represent it as a DataObject stream.

function GetTestStreamAsHex: string;
begin
  result :=
  '''
  10 14 07 42 6F 6F 6C 65
  61 6E 21 04 42 79 74 65
  02 7B 05 49 6E 74 33 32
  03 39 30 00 00 05 49 6E
  74 36 34 04 15 CD 5B 07
  00 00 00 00 06 53 69 6E
  67 6C 65 05 B7 E6 40 46
  06 44 6F 75 62 6C 65 06
  8A B0 E1 E9 D6 1C F8 40
  08 44 61 74 65 54 69 6D
  65 08 4A EE 3A 17 64 4B
  E6 40 0B 55 54 43 44 61
  74 65 54 69 6D 65 09 25
  02 76 67 00 00 00 00 04
  44 61 74 65 0A 4A EE 3A
  17 64 4B E6 40 04 54 69
  6D 65 0B 4A EE 3A 17 64
  4B E6 40 04 47 55 49 44
  0C 09 BA DC FE 34 12 21
  43 09 08 07 06 05 04 03
  02 08 4F 62 6A 65 63 74
  49 64 0D 00 01 02 03 04
  05 06 07 08 09 0A 0B 06
  53 74 72 69 6E 67 81 0B
  48 65 6C 6C 6F 20 57 6F
  72 6C 64 06 53 79 6D 62
  6F 6C A1 06 53 59 4D 42
  4F 4C 0A 53 74 72 69 6E
  67 4C 69 73 74 83 06 4B
  4A 53 4F 4E 20 28 4A 61
  76 61 53 63 72 69 70 74
  20 4F 62 6A 65 63 74 20
  4E 6F 74 61 74 69 6F 6E
  29 20 69 73 20 61 20 6C
  69 67 68 74 77 65 69 67
  68 74 20 64 61 74 61 2D
  69 6E 74 65 72 63 68 61
  6E 67 65 20 66 6F 72 6D
  61 74 2E 28 49 74 20 69
  73 20 65 61 73 79 20 66
  6F 72 20 68 75 6D 61 6E
  73 20 74 6F 20 72 65 61
  64 20 61 6E 64 20 77 72
  69 74 65 2E 2E 49 74 20
  69 73 20 65 61 73 79 20
  66 6F 72 20 6D 61 63 68
  69 6E 65 73 20 74 6F 20
  70 61 72 73 65 20 61 6E
  64 20 67 65 6E 65 72 61
  74 65 2E 6E 49 74 20 69
  73 20 62 61 73 65 64 20
  6F 6E 20 61 20 73 75 62
  73 65 74 20 6F 66 20 74
  68 65 20 4A 61 76 61 53
  63 72 69 70 74 20 50 72
  6F 67 72 61 6D 6D 69 6E
  67 20 4C 61 6E 67 75 61
  67 65 2C 20 53 74 61 6E
  64 61 72 64 20 45 43 4D
  41 2D 32 36 32 20 33 72
  64 20 45 64 69 74 69 6F
  6E 20 2D 20 44 65 63 65
  6D 62 65 72 20 31 39 39
  39 2E D8 01 4A 53 4F 4E
  20 69 73 20 61 20 74 65
  78 74 20 66 6F 72 6D 61
  74 20 74 68 61 74 20 69
  73 20 63 6F 6D 70 6C 65
  74 65 6C 79 20 6C 61 6E
  67 75 61 67 65 20 69 6E
  64 65 70 65 6E 64 65 6E
  74 20 62 75 74 20 75 73
  65 73 20 63 6F 6E 76 65
  6E 74 69 6F 6E 73 20 74
  68 61 74 20 61 72 65 20
  66 61 6D 69 6C 69 61 72
  20 74 6F 20 70 72 6F 67
  72 61 6D 6D 65 72 73 20
  6F 66 20 74 68 65 20 43
  2D 66 61 6D 69 6C 79 20
  6F 66 20 6C 61 6E 67 75
  61 67 65 73 2C 20 69 6E
  63 6C 75 64 69 6E 67 20
  43 2C 20 43 2B 2B 2C 20
  43 23 2C 20 4A 61 76 61
  2C 20 4A 61 76 61 53 63
  72 69 70 74 2C 20 50 65
  72 6C 2C 20 50 79 74 68
  6F 6E 2C 20 61 6E 64 20
  6D 61 6E 79 20 6F 74 68
  65 72 73 2E 3E 54 68 65
  73 65 20 70 72 6F 70 65
  72 74 69 65 73 20 6D 61
  6B 65 20 4A 53 4F 4E 20
  61 6E 20 69 64 65 61 6C
  20 64 61 74 61 2D 69 6E
  74 65 72 63 68 61 6E 67
  65 20 6C 61 6E 67 75 61
  67 65 2E 05 46 72 61 6D
  65 10 02 09 46 69 72 73
  74 4E 61 6D 65 81 04 53
  65 61 6E 08 4C 61 73 74
  4E 61 6D 65 81 07 53 6F
  6C 62 65 72 67 05 41 72
  72 61 79 11 14 03 00 00
  00 00 03 05 00 00 00 03
  0A 00 00 00 03 0F 00 00
  00 03 14 00 00 00 03 19
  00 00 00 03 1E 00 00 00
  03 23 00 00 00 03 28 00
  00 00 03 2D 00 00 00 03
  32 00 00 00 03 37 00 00
  00 03 3C 00 00 00 03 41
  00 00 00 03 46 00 00 00
  03 4B 00 00 00 03 50 00
  00 00 03 55 00 00 00 03
  5A 00 00 00 03 5F 00 00
  00 0B 53 70 61 72 73 65
  41 72 72 61 79 12 40 02
  81 17 4B 65 79 20 31 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  30 04 81 17 4B 65 79 20
  32 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 31 08 81 17 4B 65
  79 20 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 32 10 81 17
  4B 65 79 20 38 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 33 20
  81 18 4B 65 79 20 31 36
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 34 40 81 18 4B 65 79
  20 33 32 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 35 80 01 81
  18 4B 65 79 20 36 34 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  36 80 02 81 19 4B 65 79
  20 31 32 38 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 37 80 04
  81 19 4B 65 79 20 32 35
  36 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 38 80 08 81 19 4B
  65 79 20 35 31 32 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 39
  80 10 81 1B 4B 65 79 20
  31 30 32 34 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 31 30 80
  20 81 1B 4B 65 79 20 32
  30 34 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 31 31 80 40
  81 1B 4B 65 79 20 34 30
  39 36 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 31 32 80 80 01
  81 1B 4B 65 79 20 38 31
  39 32 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 31 33 80 80 02
  81 1C 4B 65 79 20 31 36
  33 38 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 31 34 80 80
  04 81 1C 4B 65 79 20 33
  32 37 36 38 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 31 35 80
  80 08 81 1C 4B 65 79 20
  36 35 35 33 36 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 31 36
  80 80 10 81 1D 4B 65 79
  20 31 33 31 30 37 32 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  31 37 80 80 20 81 1D 4B
  65 79 20 32 36 32 31 34
  34 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 31 38 80 80 40 81
  1D 4B 65 79 20 35 32 34
  32 38 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 31 39 80 80
  80 01 81 1E 4B 65 79 20
  31 30 34 38 35 37 36 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  32 30 80 80 80 02 81 1E
  4B 65 79 20 32 30 39 37
  31 35 32 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 32 31 80 80
  80 04 81 1E 4B 65 79 20
  34 31 39 34 33 30 34 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  32 32 80 80 80 08 81 1E
  4B 65 79 20 38 33 38 38
  36 30 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 32 33 80 80
  80 10 81 1F 4B 65 79 20
  31 36 37 37 37 32 31 36
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 32 34 80 80 80 20 81
  1F 4B 65 79 20 33 33 35
  35 34 34 33 32 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 32 35
  80 80 80 40 81 1F 4B 65
  79 20 36 37 31 30 38 38
  36 34 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 32 36 80 80 80
  80 01 81 20 4B 65 79 20
  31 33 34 32 31 37 37 32
  38 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 32 37 80 80 80 80
  02 81 20 4B 65 79 20 32
  36 38 34 33 35 34 35 36
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 32 38 80 80 80 80 04
  81 20 4B 65 79 20 35 33
  36 38 37 30 39 31 32 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  32 39 80 80 80 80 08 81
  21 4B 65 79 20 31 30 37
  33 37 34 31 38 32 34 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  33 30 80 80 80 80 10 81
  21 4B 65 79 20 32 31 34
  37 34 38 33 36 34 38 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  33 31 80 80 80 80 20 81
  21 4B 65 79 20 34 32 39
  34 39 36 37 32 39 36 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  33 32 80 80 80 80 40 81
  21 4B 65 79 20 38 35 38
  39 39 33 34 35 39 32 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  33 33 80 80 80 80 80 01
  81 22 4B 65 79 20 31 37
  31 37 39 38 36 39 31 38
  34 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 33 34 80 80 80 80
  80 02 81 22 4B 65 79 20
  33 34 33 35 39 37 33 38
  33 36 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 33 35 80 80
  80 80 80 04 81 22 4B 65
  79 20 36 38 37 31 39 34
  37 36 37 33 36 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 33 36
  80 80 80 80 80 08 81 23
  4B 65 79 20 31 33 37 34
  33 38 39 35 33 34 37 32
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 33 37 80 80 80 80 80
  10 81 23 4B 65 79 20 32
  37 34 38 37 37 39 30 36
  39 34 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 33 38 80 80
  80 80 80 20 81 23 4B 65
  79 20 35 34 39 37 35 35
  38 31 33 38 38 38 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 33
  39 80 80 80 80 80 40 81
  24 4B 65 79 20 31 30 39
  39 35 31 31 36 32 37 37
  37 36 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 34 30 80 80 80
  80 80 80 01 81 24 4B 65
  79 20 32 31 39 39 30 32
  33 32 35 35 35 35 32 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  34 31 80 80 80 80 80 80
  02 81 24 4B 65 79 20 34
  33 39 38 30 34 36 35 31
  31 31 30 34 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 34 32 80
  80 80 80 80 80 04 81 24
  4B 65 79 20 38 37 39 36
  30 39 33 30 32 32 32 30
  38 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 34 33 80 80 80 80
  80 80 08 81 25 4B 65 79
  20 31 37 35 39 32 31 38
  36 30 34 34 34 31 36 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  34 34 80 80 80 80 80 80
  10 81 25 4B 65 79 20 33
  35 31 38 34 33 37 32 30
  38 38 38 33 32 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 34 35
  80 80 80 80 80 80 20 81
  25 4B 65 79 20 37 30 33
  36 38 37 34 34 31 37 37
  36 36 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 34 36 80 80
  80 80 80 80 40 81 26 4B
  65 79 20 31 34 30 37 33
  37 34 38 38 33 35 35 33
  32 38 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 34 37 80 80 80
  80 80 80 80 01 81 26 4B
  65 79 20 32 38 31 34 37
  34 39 37 36 37 31 30 36
  35 36 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 34 38 80 80 80
  80 80 80 80 02 81 26 4B
  65 79 20 35 36 32 39 34
  39 39 35 33 34 32 31 33
  31 32 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 34 39 80 80 80
  80 80 80 80 04 81 27 4B
  65 79 20 31 31 32 35 38
  39 39 39 30 36 38 34 32
  36 32 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 35 30 80 80
  80 80 80 80 80 08 81 27
  4B 65 79 20 32 32 35 31
  37 39 39 38 31 33 36 38
  35 32 34 38 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 35 31 80
  80 80 80 80 80 80 10 81
  27 4B 65 79 20 34 35 30
  33 35 39 39 36 32 37 33
  37 30 34 39 36 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 35 32
  80 80 80 80 80 80 80 20
  81 27 4B 65 79 20 39 30
  30 37 31 39 39 32 35 34
  37 34 30 39 39 32 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 35
  33 80 80 80 80 80 80 80
  40 81 28 4B 65 79 20 31
  38 30 31 34 33 39 38 35
  30 39 34 38 31 39 38 34
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 35 34 80 80 80 80 80
  80 80 80 01 81 28 4B 65
  79 20 33 36 30 32 38 37
  39 37 30 31 38 39 36 33
  39 36 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 35 35 80 80
  80 80 80 80 80 80 02 81
  28 4B 65 79 20 37 32 30
  35 37 35 39 34 30 33 37
  39 32 37 39 33 36 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 35
  36 80 80 80 80 80 80 80
  80 04 81 29 4B 65 79 20
  31 34 34 31 31 35 31 38
  38 30 37 35 38 35 35 38
  37 32 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 35 37 80 80 80
  80 80 80 80 80 08 81 29
  4B 65 79 20 32 38 38 32
  33 30 33 37 36 31 35 31
  37 31 31 37 34 34 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 35
  38 80 80 80 80 80 80 80
  80 10 81 29 4B 65 79 20
  35 37 36 34 36 30 37 35
  32 33 30 33 34 32 33 34
  38 38 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 35 39 80 80 80
  80 80 80 80 80 20 81 2A
  4B 65 79 20 31 31 35 32
  39 32 31 35 30 34 36 30
  36 38 34 36 39 37 36 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  36 30 80 80 80 80 80 80
  80 80 40 81 2A 4B 65 79
  20 32 33 30 35 38 34 33
  30 30 39 32 31 33 36 39
  33 39 35 32 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 36 31 80
  80 80 80 80 80 80 80 80
  01 81 2A 4B 65 79 20 34
  36 31 31 36 38 36 30 31
  38 34 32 37 33 38 37 39
  30 34 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 36 32 FF FF FF
  FF FF FF FF FF FF 01 81
  2B 4B 65 79 20 2D 39 32
  32 33 33 37 32 30 33 36
  38 35 34 37 37 35 38 30
  38 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 36 33 06 42 69 6E
  61 72 79 13 18 00 01 02
  03 04 05 06 07 08 09 0A
  0B 0C 0D 0E 0F 10 11 12
  13 14 15 16 17 03 74 61
  67 15 20 81 19 68 74 74
  70 3A 2F 2F 64 61 74 61
  6F 62 6A 65 63 74 73 70
  65 63 2E 6F 72 67
  ''';

  result := StringReplace(result, ' ', '', [rfReplaceAll]);
  result := StringReplace(result, #13, '', [rfReplaceAll]);
  result := StringReplace(result, #10, '', [rfReplaceAll]);
end;


procedure TestTDataObj.SetUp;
begin
  FDataObj := TDataObj.Create;
  MakeTestObject(FDataObj);
end;

procedure TestTDataObj.TearDown;
begin
  FreeAndNil(FDataObj);
end;

procedure TestTDataObj.TestClear;
begin
  FDataObj.Clear;
  Assert.IsTrue(FDataObj.dataType.code = cDataTypeNull);  // TODO: Validate method results
end;

procedure TestTDataObj.TestClearData;
begin
  // TODO:  Add in an attribute some day and make sure it persists after .ClearData
  FDataObj.ClearData;
  Assert.IsTrue(FDataObj.dataType.code = cDataTypeNull);  // TODO: Validate method results
end;

procedure TestTDataObj.TestClearAttributes;
begin
  FDataObj.HasAttributes := true;
  FDataObj.ClearAttributes;
  Assert.IsTrue(FDataObj.HasAttributes = false);
end;

procedure TestTDataObj.TestPrintToString;
var
  lValue: string;
  lExpected: string;
begin
  lValue := FDataObj.PrintToString;

  lExpected :=
  '''
{ Boolean: True,
  Byte: 123,
  Int32: 12345,
  Int64: 123456789,
  Single: 12345.6787109375,
  Double: 98765.4321,
  DateTime: 1/2/2025 3:04:05 AM,
  UTCDateTime: 1/21/1970 2:09:47 AM,
  Date: 1/2/2025,
  Time: 3:04:05 AM,
  GUID: {FEDCBA09-1234-4321-0908-070605040302},
  ObjectId: 000102030405060708090a0b,
  String: "Hello World",
  Symbol: "SYMBOL",
  StringList: [
    `JSON (JavaScript Object Notation) is a lightweight data-interchange format.`,
    `It is easy for humans to read and write.`,
    `It is easy for machines to parse and generate.`,
    `It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.`,
    `JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others.`,
    `These properties make JSON an ideal data-interchange language.`
  ],
  Frame: { FirstName: "Sean",
    LastName: "Solberg"
  },
  Array: [ 0: 0,
    1: 5,
    2: 10,
    3: 15,
    4: 20,
    5: 25,
    6: 30,
    7: 35,
    8: 40,
    9: 45,
    10: 50,
    11: 55,
    12: 60,
    13: 65,
    14: 70,
    15: 75,
    16: 80,
    17: 85,
    18: 90,
    19: 95
  ],
  SparseArray: [ 1:"Key 1 is 1 shifted by 0",
    2:"Key 2 is 1 shifted by 1",
    4:"Key 4 is 1 shifted by 2",
    8:"Key 8 is 1 shifted by 3",
    16:"Key 16 is 1 shifted by 4",
    32:"Key 32 is 1 shifted by 5",
    64:"Key 64 is 1 shifted by 6",
    128:"Key 128 is 1 shifted by 7",
    256:"Key 256 is 1 shifted by 8",
    512:"Key 512 is 1 shifted by 9",
    1024:"Key 1024 is 1 shifted by 10",
    2048:"Key 2048 is 1 shifted by 11",
    4096:"Key 4096 is 1 shifted by 12",
    8192:"Key 8192 is 1 shifted by 13",
    16384:"Key 16384 is 1 shifted by 14",
    32768:"Key 32768 is 1 shifted by 15",
    65536:"Key 65536 is 1 shifted by 16",
    131072:"Key 131072 is 1 shifted by 17",
    262144:"Key 262144 is 1 shifted by 18",
    524288:"Key 524288 is 1 shifted by 19",
    1048576:"Key 1048576 is 1 shifted by 20",
    2097152:"Key 2097152 is 1 shifted by 21",
    4194304:"Key 4194304 is 1 shifted by 22",
    8388608:"Key 8388608 is 1 shifted by 23",
    16777216:"Key 16777216 is 1 shifted by 24",
    33554432:"Key 33554432 is 1 shifted by 25",
    67108864:"Key 67108864 is 1 shifted by 26",
    134217728:"Key 134217728 is 1 shifted by 27",
    268435456:"Key 268435456 is 1 shifted by 28",
    536870912:"Key 536870912 is 1 shifted by 29",
    1073741824:"Key 1073741824 is 1 shifted by 30",
    2147483648:"Key 2147483648 is 1 shifted by 31",
    4294967296:"Key 4294967296 is 1 shifted by 32",
    8589934592:"Key 8589934592 is 1 shifted by 33",
    17179869184:"Key 17179869184 is 1 shifted by 34",
    34359738368:"Key 34359738368 is 1 shifted by 35",
    68719476736:"Key 68719476736 is 1 shifted by 36",
    137438953472:"Key 137438953472 is 1 shifted by 37",
    274877906944:"Key 274877906944 is 1 shifted by 38",
    549755813888:"Key 549755813888 is 1 shifted by 39",
    1099511627776:"Key 1099511627776 is 1 shifted by 40",
    2199023255552:"Key 2199023255552 is 1 shifted by 41",
    4398046511104:"Key 4398046511104 is 1 shifted by 42",
    8796093022208:"Key 8796093022208 is 1 shifted by 43",
    17592186044416:"Key 17592186044416 is 1 shifted by 44",
    35184372088832:"Key 35184372088832 is 1 shifted by 45",
    70368744177664:"Key 70368744177664 is 1 shifted by 46",
    140737488355328:"Key 140737488355328 is 1 shifted by 47",
    281474976710656:"Key 281474976710656 is 1 shifted by 48",
    562949953421312:"Key 562949953421312 is 1 shifted by 49",
    1125899906842624:"Key 1125899906842624 is 1 shifted by 50",
    2251799813685248:"Key 2251799813685248 is 1 shifted by 51",
    4503599627370496:"Key 4503599627370496 is 1 shifted by 52",
    9007199254740992:"Key 9007199254740992 is 1 shifted by 53",
    18014398509481984:"Key 18014398509481984 is 1 shifted by 54",
    36028797018963968:"Key 36028797018963968 is 1 shifted by 55",
    72057594037927936:"Key 72057594037927936 is 1 shifted by 56",
    144115188075855872:"Key 144115188075855872 is 1 shifted by 57",
    288230376151711744:"Key 288230376151711744 is 1 shifted by 58",
    576460752303423488:"Key 576460752303423488 is 1 shifted by 59",
    1152921504606846976:"Key 1152921504606846976 is 1 shifted by 60",
    2305843009213693952:"Key 2305843009213693952 is 1 shifted by 61",
    4611686018427387904:"Key 4611686018427387904 is 1 shifted by 62",
    -9223372036854775808:"Key -9223372036854775808 is 1 shifted by 63"
  ],
  Binary: h'000102030405060708090A0B0C0D0E0F1011121314151617',
  tag: 32("http://dataobjectspec.org")
}
''';
  lExpected := StringReplace(lExpected, ' ','', [rfReplaceAll]);
  lValue := StringReplace(lValue, ' ','', [rfReplaceAll]);

  Assert.AreEqual(lExpected, lValue, 'PrintToString generated different results than expected.');
end;

procedure HexStringToStream(aHexStr: string; aStream: TMemoryStream);
var
  lLen: integer;
begin
  lLen := Length(aHexStr) div 2;
  aStream.SetSize(lLen);
  HexToBin(PChar(aHexStr), aStream.Memory, lLen);
end;

procedure TestTDataObj.TestWriteToStream;
var
  lStream: TMemoryStream;
  lExpectedStream: TMemoryStream;
begin
  lStream:=TMemoryStream.create;
  lExpectedStream:=TMemoryStream.create;
  try
    FDataObj.WriteToStream(lStream);
    lStream.SaveToFile('d:\temp\S1.dataObj');

    HexStringToStream(GetTestStreamAsHex, lExpectedStream);
    lStream.seek(0,soFromBeginning);
    lExpectedStream.seek(0,soFromBeginning);

    Assert.AreEqual(lStream, lExpectedStream, 'TDataObj.WriteToStream generated different results than expected.');
  finally
    lStream.Free;
    lExpectedStream.free;
  end;
end;

procedure TestTDataObj.TestReadFromStream;
var
  lStream: TStream;
  lStream2: TStream;
begin
  lStream:=TMemoryStream.create;
  lStream2:=TMemoryStream.create;
  try
    FDataObj.WriteToStream(lStream);
    lStream.Seek(0, soFromBeginning);
    TMemoryStream(lStream).SaveToFile('d:\temp\stream1.dataobj');
    fDataObj.clear;
    FDataObj.ReadFromStream(lStream);
    FDataObj.WriteToStream(lStream2);

    Assert.AreEqual(lStream, lStream2, 'TDataObj.WriteToStream/WriteToStream did not round-trip');
  finally
    lStream.Free;
    lStream2.Free;
  end;
end;

procedure TestTDataObj.TestSettingATag;
var
  lDataObj: TDataObj;
  lSlot: TDataObj;
  lExpected: string;
  lActual: string;
begin
  lDataObj:=TDataObj.create;
  try
    lSlot := lDataObj.AsFrame.newslot('TESTSLOT');
    lSlot.AsString := 'Hello World';
    lSlot.AsTag.TagValue := 999;
    lExpected := '{ TESTSLOT: 999("Hello World")}';
    lActual := lDataObj.PrintToString;
    lActual := StringReplace(lActual, #13,'',[rfReplaceAll]);
    lActual := StringReplace(lActual, #10,'',[rfReplaceAll]);

    Assert.areEqual(lExpected, lActual,'Setting a tag did not preserve it''s previous string value');
  finally
    lDataObj.free;
  end;
end;

procedure TestTDataObj.TestDataTypeIsAContainer;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FDataObj.DataTypeIsAContainer;
  Assert.AreEqual(ReturnValue, true);
end;

procedure TestTDataObj.TestCopyFrom;
var
  lCopyDataObj: TDataObj;
  lStr1, lStr2: string;
begin
  lCopyDataObj := TDataObj.create;
  try
    lCopyDataObj.CopyFrom(fDataObj);
    lStr1 := fDataObj.PrintToString;
    lStr2 := lCopyDataObj.PrintToString;
    assert.areEqual(lStr1, lStr2, 'CopyFrom resulted in different object content');
  finally
    lCopyDataobj.free;
  end;
end;


procedure TestTDataGUID.SetUp;
begin
  FDataGUID := TDataGUID.Create;
end;

procedure TestTDataGUID.TearDown;
begin
  FDataGUID.Free;
  FDataGUID := nil;
end;

procedure TestTDataObjectID.SetUp;
begin
  FDataObjectID := TDataObjectID.Create;
end;

procedure TestTDataObjectID.TearDown;
begin
  FDataObjectID.Free;
  FDataObjectID := nil;
end;

procedure TestTDataFrame.SetUp;
begin
  FDataObj := TDataObj.Create;
  FDataFrame := fDataObj.AsFrame;
end;

procedure TestTDataFrame.TearDown;
begin
  FreeAndNil(FDataObj);
end;

procedure TestTDataFrame.TestFindSlot;
var
  ReturnValue: TDataObj;
  aSlotName: string;
begin
  ReturnValue := FDataFrame.FindSlot(aSlotName);
end;

procedure TestTDataFrame.TestNewSlot;
var
  lDataObj: TDataObj;
  aSlotName: string;
  lNewSlot: TDataObj;
  lFindSlot: TDataObj;
begin
  lDataObj := TDataObj.create;
  lNewSlot := lDataObj.AsFrame.newslot('TEST');
  lFindSlot := lDataObj.AsFrame.findSlot('TEST');

  assert.AreEqual(lNewSlot, lFindSlot, 'Find Slot Did not return the expected result');
end;

procedure TestTDataFrame.TestSlotByName;
begin
  // TODO: Setup method call parameters
  fDataFrame.NewSlot('TESTSLOT');
  if not assigned(FDataFrame.SlotByName('TESTSLOT')) then
  begin
    raise Exception.Create('Unable to find slot with .SlotByName');
  end;
  // TODO: Validate method results
end;

procedure TestTDataFrame.TestDeleteSlot;
var
  ReturnValue: Boolean;
  aSlotName: string;
begin
  // TODO: Setup method call parameters
  fDataFrame.NewSlot('TESTSLOT');
  FDataFrame.DeleteSlot('TESTSLOT');
  if assigned(FDataFrame.FindSlot('TESTSLOT')) then
  begin
    raise exception.Create('Unable to Delete a slot with call to .DeleteSlot');
  end;

  // TODO: Validate method results
end;

procedure TestTDataFrame.TestDelete;
var
  ReturnValue: Boolean;
  lIndex: Integer;
  lSlot: TDataObj;
begin
  // TODO: Setup method call parameters
  lSlot:=fDataFrame.NewSlot('TESTSLOT');
  lIndex := fDataFrame.IndexOfChildSlot(lSlot);
  if FDataFrame.Delete(lIndex) = false then
  begin
    raise Exception.Create('unable to Delete Slot with index: '+InttoStr(lIndex));
  end;

end;

procedure TestTDataFrame.TestSlotname;
var
  ReturnValue: string;
  lSlot: TDataObj;
  lIndex: integer;
begin
  lSlot:=fDataFrame.NewSlot('TESTSLOT');
  lIndex := fDataFrame.IndexOfChildSlot(lSlot);
  ReturnValue := FDataFrame.Slotname(lIndex);
  if ReturnValue <> 'TESTSLOT' then
  begin
    raise Exception.Create('Slotname unable to be found with index: '+InttoStr(lIndex));
  end;
end;

procedure TestTDataFrame.TestCount;
var
  ReturnValue: Integer;
begin
  ReturnValue := FDataFrame.Count;
  // TODO: Validate method results
end;

procedure TestTDataFrame.TestClear;
begin
  FDataFrame.Clear;
  // TODO: Validate method results
end;

procedure TestTDataFrame.TestCopyFrom;
var
  lObj: TDataObj;
  lObj2: TDataObj;
begin
  lObj:=TDataObj.Create;
  lObj2:=TDataObj.Create;
  try
    MakeTestObject(lObj);
    lObj2.CopyFrom(lObj);
    if lObj.PrintToString <> lObj2.PrintToString then
    begin
      raise Exception.Create('TDataobj.CopyFrom did not create an exact copy.');
    end;
  finally
    lObj.Free;
    lObj2.Free;
  end;
end;

procedure TestTDataArray.SetUp;
begin
  FDataArray := TDataArray.Create;
end;

procedure TestTDataArray.TearDown;
begin
  FDataArray.Free;
  FDataArray := nil;
end;

procedure TestTDataArray.TestNewSlot;
var
  ReturnValue: TDataObj;
begin
//  ReturnValue := FDataArray.NewSlot;
  // TODO: Validate method results
end;

procedure TestTDataArray.TestFind;
var
  ReturnValue: TDataObj;
  aFindFunction: TForEachFunction;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FDataArray.Find(aFindFunction);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestForEach;
var
  aReverseOrder: Boolean;
  aForEachFunction: TForEachProcedure;
begin
  // TODO: Setup method call parameters
//  FDataArray.ForEach(aForEachFunction, aReverseOrder);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestEvery;
var
  ReturnValue: Boolean;
  aEveryFunction: TForEachFunction;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FDataArray.Every(aEveryFunction);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestIndexOf;
var
  ReturnValue: Integer;
  aCaseInsensitive: Boolean;
  aString: string;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FDataArray.IndexOf(aString, aCaseInsensitive);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestLastIndexOf;
var
  ReturnValue: Integer;
  aCaseInsensitive: Boolean;
  aString: string;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FDataArray.LastIndexOf(aString, aCaseInsensitive);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestRemoveForEach;
var
  ReturnValue: Integer;
  aEveryFunction: TForEachFunction;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FDataArray.RemoveForEach(aEveryFunction);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestReduce;
var
  ReturnValue: TDataObj;
  aReduceProcedure: TReduceProcedure;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FDataArray.Reduce(aReduceProcedure);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestMap;
var
  ReturnValue: TDataObj;
  aMapProcedure: TMapProcedure;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FDataArray.Map(aMapProcedure);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestConcat;
var
  ReturnValue: TDataObj;
  aArray: TDataArray;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FDataArray.Concat(aArray);
  // TODO: Validate method results
end;

procedure TestTDataArray.TestAppendFrom;
var
  aArray: TDataArray;
begin
  // TODO: Setup method call parameters
//  FDataArray.AppendFrom(aArray);
  // TODO: Validate method results
end;

procedure TestTDataSparseArray.SetUp;
var
  lVal: int64;
begin
  fDataObj := TDataObj.create;
  FSparseArray := fDataObj.AsSparseArray;
  for lVal in cTestSet do
  begin
    FSparseArray.NewSlot(lVal,true).AsInt64 := lVal;
  end;
end;

procedure TestTDataSparseArray.TearDown;
begin
  fDataObj.Free;
  fDataObj := nil;
end;

procedure TestTDataSparseArray.TestFindSlot;
var
  lVal: int64;

  procedure DoTest(aIndex: int64);
  var
    lSlot: TDataObj;
  begin
    lSlot := FSparseArray.FindSlot(aIndex);
    Assert.IsNotNull(lSlot, 'Unable to lookup index '+IntToStr(aIndex)+' in sparse Array');
    if assigned(lSlot) then
      Assert.AreEqual(lSlot.AsInt64, aIndex, 'Value retrieved of '+IntToStr(lSlot.AsInt64) +' did not match expected value of '+IntToStr(aIndex));
  end;
begin
  for lVal in cTestSet do
  begin
    DoTest(lVal);
  end;
end;

procedure TestTDataSparseArray.TestNewSlot;
var
  ReturnValue: TDataObj;
  aSlotIndex: Integer;
begin
  ReturnValue := FSparseArray.NewSlot(-99, true);
  assert.IsNotNull(ReturnValue, 'Calling NewSlot did not return a new object');
end;


procedure TestTDataSparseArray.TestSlotByIndex;
var
  lVal: int64;

  procedure DoTest(aIndex: int64);
  var
    lSlot: TDataObj;
  begin
    lSlot := FSparseArray.SlotByIndex(aIndex);
    Assert.IsNotNull(lSlot, 'Unable to lookup index '+IntToStr(aIndex)+' in sparse Array');
    if assigned(lSlot) then
      Assert.AreEqual(lSlot.AsInt64, aIndex, 'Value retrieved of '+IntToStr(lSlot.AsInt64) +' did not match expected value of '+IntToStr(aIndex));
  end;

begin
  for lVal in cTestSet do
  begin
    DoTest(lVal);
  end;
end;

procedure TestTDataSparseArray.TestDeleteSlot;
var
  lVal: int64;
  procedure DoTest(aInt64: int64);
  begin
    FSparseArray.DeleteSlot(aInt64);
  end;
begin
  for lVal in cTestSet do
  begin
    DoTest(lVal);
  end;

  Assert.AreEqual(fSparseArray.count, 0, 'Deleting all test slots by SlotIndex failed to delete all slots in the test sparse array.');
end;

procedure TestTDataSparseArray.TestSlotIndex;
var
  ReturnValue: Integer;
  aIndex: Integer;
  i: Integer;
  lVal: Int64;
  lCount: integer;

  procedure DoTest(aIndex: integer; aValue: int64);
  begin
    Assert.AreEqual(FSparseArray.SlotIndex(aIndex), aValue, 'SlotIndex returned an unexpected value');
  end;
begin
  lCount := 0;
  for lVal in cTestSet do
  begin
    DoTest(lCount,lVal);
    inc(lCount);
  end;
end;

procedure TestTDataSparseArray.TestClear;
begin
  FSparseArray.Clear;
  Assert.areEqual(0,fSparseArray.count, 'Test Clear did not fully clear the SparseArray');
end;

procedure TestTDataSparseArray.TestCopyFrom;
var
  aCopyDataObj: TDataObj;
  lMain: string;
  lCopy: string;
begin
  aCopyDataObj := TDataObj.create;
  try
    aCopyDataObj.AsSparseArray.copyFrom(fSparseArray);
    lMain := FDataObj.PrintToString;
    lCopy := FDataObj.PrintToString;
    assert.AreEqual(lMain, lCopy, 'SparseArray.CopyFrom failed to preserve exact data.');
  finally
    aCopyDataObj.free;
  end;
end;



{ TestVarInts }

procedure TestVarInts.TestVarInt32;
  procedure DoTest(aInt: Int32);
  var
    lInt2: Int32;
    lUInt: UInt32;
  begin
    lUInt := TVarInt32.ZigZagEncode32(aInt);
    lInt2 := TVarInt32.ZigZagDecode32(lUInt);
    Assert.AreEqual(aInt, lInt2, IntToStr(aInt)+' Roundtrip to zigzag and back failed. returned as '+IntToStr(lInt2));
  end;
begin
  DoTest(0);
  DoTest(1);
  DoTest(2);
  DoTest(3);
  DoTest(-1);
  DoTest(Int32($7fffffff));
  DoTest(Int32($80000000));
  DoTest(Int32($ffffffff));
  DoTest(Int32($ffffffff));
end;

procedure TestVarInts.TestVarInt64;
  procedure DoTest(aInt: Int64);
  var
    lInt2: Int64;
    lUInt: UInt64;
  begin
    lUInt := TVarInt64.ZigZagEncode64(aInt);
    lInt2 := TVarInt64.ZigZagDecode64(lUInt);
    Assert.AreEqual(aInt, lInt2, IntToStr(aInt)+' Roundtrip to zigzag and back failed. returned as '+IntToStr(lInt2));
  end;
begin
  DoTest(0);
  DoTest(1);
  DoTest(2);
  DoTest(3);
  DoTest(-1);
  DoTest(Int64($7fffffffffffffff));
  DoTest(Int64($8000000000000000));
  DoTest(Int64($ffffffffffffffff));
  DoTest(Int64($fffffffffffffffe));
end;

initialization
  // Register any test cases with the test runner
  TDUnitX.RegisterTestFixture(TestTDataObj);
  TDUnitX.RegisterTestFixture(TestTDataGUID);
  TDUnitX.RegisterTestFixture(TestTDataObjectID);
  TDUnitX.RegisterTestFixture(TestTDataFrame);
  TDUnitX.RegisterTestFixture(TestTDataArray);
  TDUnitX.RegisterTestFixture(TestTDataSparseArray);
  TDUnitX.RegisterTestFixture(TestVarInts);


(*  RegisterTest(TestTDataObj.Suite);
  RegisterTest(TestTDataGUID.Suite);
  RegisterTest(TestTDataObjectID.Suite);
  RegisterTest(TestTDataFrame.Suite);
  RegisterTest(TestTDataArray.Suite);
  RegisterTest(TestTDataSparseArray.Suite);
  RegisterTest(TestTDataAttributeStore.Suite); *)
end.

