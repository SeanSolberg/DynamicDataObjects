unit TestDataObjects;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

{$M+}

interface

uses
  windows, DUnitX.TestFramework, DUnitX.DUnitCompatibility, Generics.collections, classes, DataObjects2, SysUtils, VarInt,
  StreamCache, DateUtils, contnrs, math, UnicodeData;

type

  TestVarInts = class(TTestCase)
  published
    procedure TestVarInt64;
    procedure TestVarInt32;
  end;

  // Test methods for class TDataObj
  TestTDataObj = class(TTestCase)
  strict private
    FDataObj: TDataObj;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestClear;
    procedure TestClearData;
    procedure TestClearAttributes;
    procedure TestPrintToString;
    procedure TestWriteToStream;
    procedure TestReadFromStream;
    procedure TestDataTypeIsAContainer;
    procedure TestCopyFrom;
    procedure TestSettingATag;
  end;
  // Test methods for class TDataGUID

  TestTDataGUID = class(TTestCase)
  strict private
    FDataGUID: TDataGUID;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  end;
  // Test methods for class TDataObjectID

  TestTDataObjectID = class(TTestCase)
  strict private
    FDataObjectID: TDataObjectID;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  end;
  // Test methods for class TDataFrame

  TestTDataFrame = class(TTestCase)
  strict private
    FDataObj: TDataObj;
    FDataFrame: TDataFrame;  // reference, not owned.
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestFindSlot;
    procedure TestNewSlot;
    procedure TestSlotByName;
    procedure TestDeleteSlot;
    procedure TestDelete;
    procedure TestSlotname;
    procedure TestCount;
    procedure TestClear;
    procedure TestCopyFrom;
    procedure TestCaseSensitive;
  end;
  // Test methods for class TDataArray

  TestTDataArray = class(TTestCase)
  strict private
    FDataObj: TDataObj;
    FDataArray: TDataArray;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestNewSlot;
    procedure TestFind;
    procedure TestForEach;
    procedure TestEvery;
    procedure TestIndexOf;
    procedure TestLastIndexOf;
    procedure TestRemoveForEach;
    procedure TestReduce;
    procedure TestMap;
    procedure TestConcat;
    procedure TestAppendFrom;
  end;
  // Test methods for class TDataSparseArray

  TestTDataSparseArray = class(TTestCase)
  const
    cTestSet: array[0..12] of int64 = (1, 10, 100, 1000, 10000, 100000, $7FFFFFFFFFFFFFFF, -1, -10, -100, -1000, -10000, -100000);
  strict private
    FDataObj: TDataObj;
    fSparseArray: TDataSparseArray;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestFindSlot;
    procedure TestNewSlot;
    procedure TestSlotByIndex;
    procedure TestDeleteSlot;
    procedure TestSlotIndex;
    procedure TestClear;
    procedure TestCopyFrom;
  end;
  // Test methods for class TDataAttributeStore


  TestUnicodeCompareText = class(TTestCase)
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCompareText;
  end;


implementation

procedure MakeTestObject(aObj: TDataObj);
var
  i: integer;
  lGUID: TGUID;
  lbuffer: array[0..23] of byte;  // NOTE: that UBJSON does not like serializing binary data... very inefficient, but some of the other serialzations are more binary friendly.
  lDT: TDateTime;
  j: int64;
  lVal: int64;
begin
  lDT := EncodeDateTime(2025,1,2,3,4,5,6);
  with aObj.AsFrame do
  begin
    newSlot('Boolean').AsBoolean := true;
    newSlot('Byte').AsByte := 123;
    newSlot('Int32').AsInt32 := 12345;
    newSlot('Int64').AsInt64 := 123456789;
    newSlot('Single').AsSingle := 12345.6789;
    newSlot('Double').AsDouble := 98765.4321;
    newSlot('DateTime').AsDateTime := lDT;
    newSlot('UTCDateTime').AsUTCDateTime := DateTimeToUnix(lDT);
    newSlot('Date').AsDate := lDT;
    newSlot('Time').AsTime := lDT;

    lGUID.D1 := $FEDCBA09;
    lGUID.D2 := $1234;
    lGUID.D3 := $4321;
    lGUID.D4[0] := 9;
    lGUID.D4[1] := 8;
    lGUID.D4[2] := 7;
    lGUID.D4[3] := 6;
    lGUID.D4[4] := 5;
    lGUID.D4[5] := 4;
    lGUID.D4[6] := 3;
    lGUID.D4[7] := 2;
    newSlot('GUID').AsGUID.GUID := lGUID;

    with newSlot('ObjectId').AsObjectID do
    begin
      for i := 0 to 11 do
        Data[i] := byte(i);
    end;

    newSlot('String').AsString := 'Hello World';
    newSlot('Symbol').AsSymbol := 'SYMBOL';
    with newSlot('StringList').AsStringList do
    begin
      Add('JSON (JavaScript Object Notation) is a lightweight data-interchange format.');
      Add('It is easy for humans to read and write.');
      Add('It is easy for machines to parse and generate.');
      Add('It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.');
      Add('JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others.');
      Add('These properties make JSON an ideal data-interchange language.');
    end;
    with newSlot('Frame').AsFrame do
    begin
      NewSlot('FirstName').AsString := 'Sean';
      Newslot('LastName').AsString := 'Solberg';
    end;

    with newSlot('Array').AsArray do
    begin
      for i := 0 to 19 do
        newSlot.AsInt32 := i*5;
    end;

    with newSlot('SparseArray').AsSparseArray do
    begin
      for j := 0 to 63 do
      begin
        lVal := int64(1) shl j;
        newSlot(lVal).AsString := 'Key '+IntToStr(lVal)+' is 1 shifted by '+IntToStr(j);
      end;
    end;

    for i := low(lbuffer) to high(lbuffer) do
      lBuffer[i] := byte(i);

    newSlot('Binary').AsBinary.Write(lbuffer, sizeof(lbuffer));

    // This is showing the ability to create a dataObject that is a TAG.  That tag then has a TagValue and an internal DataObj that can be set to anything.
    // This is mostly a feature to support Tags in CBOR.   See the CBOR streamer for details.
    with newSlot('tag').AsTag do
    begin
      TagValue := 32;
      DataObj.AsString := 'http://dataobjectspec.org';
    end;
  end;
end;

// NOTE:  If the code above changes at all in producing sample data, then the code below must be reproduced to represent it as a DataObject stream.

function GetTestStreamAsHex: string;
begin
  result :=
  '''
  10 14 07 42 6F 6F 6C 65
  61 6E 21 04 42 79 74 65
  02 7B 05 49 6E 74 33 32
  03 39 30 00 00 05 49 6E
  74 36 34 04 15 CD 5B 07
  00 00 00 00 06 53 69 6E
  67 6C 65 05 B7 E6 40 46
  06 44 6F 75 62 6C 65 06
  8A B0 E1 E9 D6 1C F8 40
  08 44 61 74 65 54 69 6D
  65 08 4A EE 3A 17 64 4B
  E6 40 0B 55 54 43 44 61
  74 65 54 69 6D 65 09 25
  02 76 67 00 00 00 00 04
  44 61 74 65 0A 4A EE 3A
  17 64 4B E6 40 04 54 69
  6D 65 0B 4A EE 3A 17 64
  4B E6 40 04 47 55 49 44
  0C 09 BA DC FE 34 12 21
  43 09 08 07 06 05 04 03
  02 08 4F 62 6A 65 63 74
  49 64 0D 00 01 02 03 04
  05 06 07 08 09 0A 0B 06
  53 74 72 69 6E 67 81 0B
  48 65 6C 6C 6F 20 57 6F
  72 6C 64 06 53 79 6D 62
  6F 6C A1 06 53 59 4D 42
  4F 4C 0A 53 74 72 69 6E
  67 4C 69 73 74 83 06 4B
  4A 53 4F 4E 20 28 4A 61
  76 61 53 63 72 69 70 74
  20 4F 62 6A 65 63 74 20
  4E 6F 74 61 74 69 6F 6E
  29 20 69 73 20 61 20 6C
  69 67 68 74 77 65 69 67
  68 74 20 64 61 74 61 2D
  69 6E 74 65 72 63 68 61
  6E 67 65 20 66 6F 72 6D
  61 74 2E 28 49 74 20 69
  73 20 65 61 73 79 20 66
  6F 72 20 68 75 6D 61 6E
  73 20 74 6F 20 72 65 61
  64 20 61 6E 64 20 77 72
  69 74 65 2E 2E 49 74 20
  69 73 20 65 61 73 79 20
  66 6F 72 20 6D 61 63 68
  69 6E 65 73 20 74 6F 20
  70 61 72 73 65 20 61 6E
  64 20 67 65 6E 65 72 61
  74 65 2E 6E 49 74 20 69
  73 20 62 61 73 65 64 20
  6F 6E 20 61 20 73 75 62
  73 65 74 20 6F 66 20 74
  68 65 20 4A 61 76 61 53
  63 72 69 70 74 20 50 72
  6F 67 72 61 6D 6D 69 6E
  67 20 4C 61 6E 67 75 61
  67 65 2C 20 53 74 61 6E
  64 61 72 64 20 45 43 4D
  41 2D 32 36 32 20 33 72
  64 20 45 64 69 74 69 6F
  6E 20 2D 20 44 65 63 65
  6D 62 65 72 20 31 39 39
  39 2E D8 01 4A 53 4F 4E
  20 69 73 20 61 20 74 65
  78 74 20 66 6F 72 6D 61
  74 20 74 68 61 74 20 69
  73 20 63 6F 6D 70 6C 65
  74 65 6C 79 20 6C 61 6E
  67 75 61 67 65 20 69 6E
  64 65 70 65 6E 64 65 6E
  74 20 62 75 74 20 75 73
  65 73 20 63 6F 6E 76 65
  6E 74 69 6F 6E 73 20 74
  68 61 74 20 61 72 65 20
  66 61 6D 69 6C 69 61 72
  20 74 6F 20 70 72 6F 67
  72 61 6D 6D 65 72 73 20
  6F 66 20 74 68 65 20 43
  2D 66 61 6D 69 6C 79 20
  6F 66 20 6C 61 6E 67 75
  61 67 65 73 2C 20 69 6E
  63 6C 75 64 69 6E 67 20
  43 2C 20 43 2B 2B 2C 20
  43 23 2C 20 4A 61 76 61
  2C 20 4A 61 76 61 53 63
  72 69 70 74 2C 20 50 65
  72 6C 2C 20 50 79 74 68
  6F 6E 2C 20 61 6E 64 20
  6D 61 6E 79 20 6F 74 68
  65 72 73 2E 3E 54 68 65
  73 65 20 70 72 6F 70 65
  72 74 69 65 73 20 6D 61
  6B 65 20 4A 53 4F 4E 20
  61 6E 20 69 64 65 61 6C
  20 64 61 74 61 2D 69 6E
  74 65 72 63 68 61 6E 67
  65 20 6C 61 6E 67 75 61
  67 65 2E 05 46 72 61 6D
  65 10 02 09 46 69 72 73
  74 4E 61 6D 65 81 04 53
  65 61 6E 08 4C 61 73 74
  4E 61 6D 65 81 07 53 6F
  6C 62 65 72 67 05 41 72
  72 61 79 11 14 03 00 00
  00 00 03 05 00 00 00 03
  0A 00 00 00 03 0F 00 00
  00 03 14 00 00 00 03 19
  00 00 00 03 1E 00 00 00
  03 23 00 00 00 03 28 00
  00 00 03 2D 00 00 00 03
  32 00 00 00 03 37 00 00
  00 03 3C 00 00 00 03 41
  00 00 00 03 46 00 00 00
  03 4B 00 00 00 03 50 00
  00 00 03 55 00 00 00 03
  5A 00 00 00 03 5F 00 00
  00 0B 53 70 61 72 73 65
  41 72 72 61 79 12 40 02
  81 17 4B 65 79 20 31 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  30 04 81 17 4B 65 79 20
  32 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 31 08 81 17 4B 65
  79 20 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 32 10 81 17
  4B 65 79 20 38 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 33 20
  81 18 4B 65 79 20 31 36
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 34 40 81 18 4B 65 79
  20 33 32 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 35 80 01 81
  18 4B 65 79 20 36 34 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  36 80 02 81 19 4B 65 79
  20 31 32 38 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 37 80 04
  81 19 4B 65 79 20 32 35
  36 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 38 80 08 81 19 4B
  65 79 20 35 31 32 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 39
  80 10 81 1B 4B 65 79 20
  31 30 32 34 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 31 30 80
  20 81 1B 4B 65 79 20 32
  30 34 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 31 31 80 40
  81 1B 4B 65 79 20 34 30
  39 36 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 31 32 80 80 01
  81 1B 4B 65 79 20 38 31
  39 32 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 31 33 80 80 02
  81 1C 4B 65 79 20 31 36
  33 38 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 31 34 80 80
  04 81 1C 4B 65 79 20 33
  32 37 36 38 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 31 35 80
  80 08 81 1C 4B 65 79 20
  36 35 35 33 36 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 31 36
  80 80 10 81 1D 4B 65 79
  20 31 33 31 30 37 32 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  31 37 80 80 20 81 1D 4B
  65 79 20 32 36 32 31 34
  34 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 31 38 80 80 40 81
  1D 4B 65 79 20 35 32 34
  32 38 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 31 39 80 80
  80 01 81 1E 4B 65 79 20
  31 30 34 38 35 37 36 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  32 30 80 80 80 02 81 1E
  4B 65 79 20 32 30 39 37
  31 35 32 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 32 31 80 80
  80 04 81 1E 4B 65 79 20
  34 31 39 34 33 30 34 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  32 32 80 80 80 08 81 1E
  4B 65 79 20 38 33 38 38
  36 30 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 32 33 80 80
  80 10 81 1F 4B 65 79 20
  31 36 37 37 37 32 31 36
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 32 34 80 80 80 20 81
  1F 4B 65 79 20 33 33 35
  35 34 34 33 32 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 32 35
  80 80 80 40 81 1F 4B 65
  79 20 36 37 31 30 38 38
  36 34 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 32 36 80 80 80
  80 01 81 20 4B 65 79 20
  31 33 34 32 31 37 37 32
  38 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 32 37 80 80 80 80
  02 81 20 4B 65 79 20 32
  36 38 34 33 35 34 35 36
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 32 38 80 80 80 80 04
  81 20 4B 65 79 20 35 33
  36 38 37 30 39 31 32 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  32 39 80 80 80 80 08 81
  21 4B 65 79 20 31 30 37
  33 37 34 31 38 32 34 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  33 30 80 80 80 80 10 81
  21 4B 65 79 20 32 31 34
  37 34 38 33 36 34 38 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  33 31 80 80 80 80 20 81
  21 4B 65 79 20 34 32 39
  34 39 36 37 32 39 36 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  33 32 80 80 80 80 40 81
  21 4B 65 79 20 38 35 38
  39 39 33 34 35 39 32 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  33 33 80 80 80 80 80 01
  81 22 4B 65 79 20 31 37
  31 37 39 38 36 39 31 38
  34 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 33 34 80 80 80 80
  80 02 81 22 4B 65 79 20
  33 34 33 35 39 37 33 38
  33 36 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 33 35 80 80
  80 80 80 04 81 22 4B 65
  79 20 36 38 37 31 39 34
  37 36 37 33 36 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 33 36
  80 80 80 80 80 08 81 23
  4B 65 79 20 31 33 37 34
  33 38 39 35 33 34 37 32
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 33 37 80 80 80 80 80
  10 81 23 4B 65 79 20 32
  37 34 38 37 37 39 30 36
  39 34 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 33 38 80 80
  80 80 80 20 81 23 4B 65
  79 20 35 34 39 37 35 35
  38 31 33 38 38 38 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 33
  39 80 80 80 80 80 40 81
  24 4B 65 79 20 31 30 39
  39 35 31 31 36 32 37 37
  37 36 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 34 30 80 80 80
  80 80 80 01 81 24 4B 65
  79 20 32 31 39 39 30 32
  33 32 35 35 35 35 32 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  34 31 80 80 80 80 80 80
  02 81 24 4B 65 79 20 34
  33 39 38 30 34 36 35 31
  31 31 30 34 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 34 32 80
  80 80 80 80 80 04 81 24
  4B 65 79 20 38 37 39 36
  30 39 33 30 32 32 32 30
  38 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 34 33 80 80 80 80
  80 80 08 81 25 4B 65 79
  20 31 37 35 39 32 31 38
  36 30 34 34 34 31 36 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  34 34 80 80 80 80 80 80
  10 81 25 4B 65 79 20 33
  35 31 38 34 33 37 32 30
  38 38 38 33 32 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 34 35
  80 80 80 80 80 80 20 81
  25 4B 65 79 20 37 30 33
  36 38 37 34 34 31 37 37
  36 36 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 34 36 80 80
  80 80 80 80 40 81 26 4B
  65 79 20 31 34 30 37 33
  37 34 38 38 33 35 35 33
  32 38 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 34 37 80 80 80
  80 80 80 80 01 81 26 4B
  65 79 20 32 38 31 34 37
  34 39 37 36 37 31 30 36
  35 36 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 34 38 80 80 80
  80 80 80 80 02 81 26 4B
  65 79 20 35 36 32 39 34
  39 39 35 33 34 32 31 33
  31 32 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 34 39 80 80 80
  80 80 80 80 04 81 27 4B
  65 79 20 31 31 32 35 38
  39 39 39 30 36 38 34 32
  36 32 34 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 35 30 80 80
  80 80 80 80 80 08 81 27
  4B 65 79 20 32 32 35 31
  37 39 39 38 31 33 36 38
  35 32 34 38 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 35 31 80
  80 80 80 80 80 80 10 81
  27 4B 65 79 20 34 35 30
  33 35 39 39 36 32 37 33
  37 30 34 39 36 20 69 73
  20 31 20 73 68 69 66 74
  65 64 20 62 79 20 35 32
  80 80 80 80 80 80 80 20
  81 27 4B 65 79 20 39 30
  30 37 31 39 39 32 35 34
  37 34 30 39 39 32 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 35
  33 80 80 80 80 80 80 80
  40 81 28 4B 65 79 20 31
  38 30 31 34 33 39 38 35
  30 39 34 38 31 39 38 34
  20 69 73 20 31 20 73 68
  69 66 74 65 64 20 62 79
  20 35 34 80 80 80 80 80
  80 80 80 01 81 28 4B 65
  79 20 33 36 30 32 38 37
  39 37 30 31 38 39 36 33
  39 36 38 20 69 73 20 31
  20 73 68 69 66 74 65 64
  20 62 79 20 35 35 80 80
  80 80 80 80 80 80 02 81
  28 4B 65 79 20 37 32 30
  35 37 35 39 34 30 33 37
  39 32 37 39 33 36 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 35
  36 80 80 80 80 80 80 80
  80 04 81 29 4B 65 79 20
  31 34 34 31 31 35 31 38
  38 30 37 35 38 35 35 38
  37 32 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 35 37 80 80 80
  80 80 80 80 80 08 81 29
  4B 65 79 20 32 38 38 32
  33 30 33 37 36 31 35 31
  37 31 31 37 34 34 20 69
  73 20 31 20 73 68 69 66
  74 65 64 20 62 79 20 35
  38 80 80 80 80 80 80 80
  80 10 81 29 4B 65 79 20
  35 37 36 34 36 30 37 35
  32 33 30 33 34 32 33 34
  38 38 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 35 39 80 80 80
  80 80 80 80 80 20 81 2A
  4B 65 79 20 31 31 35 32
  39 32 31 35 30 34 36 30
  36 38 34 36 39 37 36 20
  69 73 20 31 20 73 68 69
  66 74 65 64 20 62 79 20
  36 30 80 80 80 80 80 80
  80 80 40 81 2A 4B 65 79
  20 32 33 30 35 38 34 33
  30 30 39 32 31 33 36 39
  33 39 35 32 20 69 73 20
  31 20 73 68 69 66 74 65
  64 20 62 79 20 36 31 80
  80 80 80 80 80 80 80 80
  01 81 2A 4B 65 79 20 34
  36 31 31 36 38 36 30 31
  38 34 32 37 33 38 37 39
  30 34 20 69 73 20 31 20
  73 68 69 66 74 65 64 20
  62 79 20 36 32 FF FF FF
  FF FF FF FF FF FF 01 81
  2B 4B 65 79 20 2D 39 32
  32 33 33 37 32 30 33 36
  38 35 34 37 37 35 38 30
  38 20 69 73 20 31 20 73
  68 69 66 74 65 64 20 62
  79 20 36 33 06 42 69 6E
  61 72 79 13 18 00 01 02
  03 04 05 06 07 08 09 0A
  0B 0C 0D 0E 0F 10 11 12
  13 14 15 16 17 03 74 61
  67 15 20 81 19 68 74 74
  70 3A 2F 2F 64 61 74 61
  6F 62 6A 65 63 74 73 70
  65 63 2E 6F 72 67
  ''';

  result := StringReplace(result, ' ', '', [rfReplaceAll]);
  result := StringReplace(result, #13, '', [rfReplaceAll]);
  result := StringReplace(result, #10, '', [rfReplaceAll]);
end;


procedure TestTDataObj.SetUp;
begin
  FDataObj := TDataObj.Create;
  MakeTestObject(FDataObj);
end;

procedure TestTDataObj.TearDown;
begin
  FreeAndNil(FDataObj);
end;


procedure TestTDataObj.TestClear;
begin
  FDataObj.Clear;
  Assert.IsTrue(FDataObj.dataType.code = cDataTypeNull);  // TODO: Validate method results
end;

procedure TestTDataObj.TestClearData;
begin
  // TODO:  Add in an attribute some day and make sure it persists after .ClearData
  FDataObj.ClearData;
  Assert.IsTrue(FDataObj.dataType.code = cDataTypeNull);  // TODO: Validate method results
end;

procedure TestTDataObj.TestClearAttributes;
begin
  FDataObj.HasAttributes := true;
  FDataObj.ClearAttributes;
  Assert.IsTrue(FDataObj.HasAttributes = false);
end;

procedure TestTDataObj.TestPrintToString;
var
  lValue: string;
  lExpected: string;
begin
  lValue := FDataObj.PrintToString;

  lExpected :=
  '''
{ Boolean: True,
  Byte: 123,
  Int32: 12345,
  Int64: 123456789,
  Single: 12345.6787109375,
  Double: 98765.4321,
  DateTime: 1/2/2025 3:04:05 AM,
  UTCDateTime: 1/21/1970 2:09:47 AM,
  Date: 1/2/2025,
  Time: 3:04:05 AM,
  GUID: {FEDCBA09-1234-4321-0908-070605040302},
  ObjectId: 000102030405060708090a0b,
  String: "Hello World",
  Symbol: "SYMBOL",
  StringList: [
    `JSON (JavaScript Object Notation) is a lightweight data-interchange format.`,
    `It is easy for humans to read and write.`,
    `It is easy for machines to parse and generate.`,
    `It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.`,
    `JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others.`,
    `These properties make JSON an ideal data-interchange language.`
  ],
  Frame: { FirstName: "Sean",
    LastName: "Solberg"
  },
  Array: [ 0: 0,
    1: 5,
    2: 10,
    3: 15,
    4: 20,
    5: 25,
    6: 30,
    7: 35,
    8: 40,
    9: 45,
    10: 50,
    11: 55,
    12: 60,
    13: 65,
    14: 70,
    15: 75,
    16: 80,
    17: 85,
    18: 90,
    19: 95
  ],
  SparseArray: [ 1:"Key 1 is 1 shifted by 0",
    2:"Key 2 is 1 shifted by 1",
    4:"Key 4 is 1 shifted by 2",
    8:"Key 8 is 1 shifted by 3",
    16:"Key 16 is 1 shifted by 4",
    32:"Key 32 is 1 shifted by 5",
    64:"Key 64 is 1 shifted by 6",
    128:"Key 128 is 1 shifted by 7",
    256:"Key 256 is 1 shifted by 8",
    512:"Key 512 is 1 shifted by 9",
    1024:"Key 1024 is 1 shifted by 10",
    2048:"Key 2048 is 1 shifted by 11",
    4096:"Key 4096 is 1 shifted by 12",
    8192:"Key 8192 is 1 shifted by 13",
    16384:"Key 16384 is 1 shifted by 14",
    32768:"Key 32768 is 1 shifted by 15",
    65536:"Key 65536 is 1 shifted by 16",
    131072:"Key 131072 is 1 shifted by 17",
    262144:"Key 262144 is 1 shifted by 18",
    524288:"Key 524288 is 1 shifted by 19",
    1048576:"Key 1048576 is 1 shifted by 20",
    2097152:"Key 2097152 is 1 shifted by 21",
    4194304:"Key 4194304 is 1 shifted by 22",
    8388608:"Key 8388608 is 1 shifted by 23",
    16777216:"Key 16777216 is 1 shifted by 24",
    33554432:"Key 33554432 is 1 shifted by 25",
    67108864:"Key 67108864 is 1 shifted by 26",
    134217728:"Key 134217728 is 1 shifted by 27",
    268435456:"Key 268435456 is 1 shifted by 28",
    536870912:"Key 536870912 is 1 shifted by 29",
    1073741824:"Key 1073741824 is 1 shifted by 30",
    2147483648:"Key 2147483648 is 1 shifted by 31",
    4294967296:"Key 4294967296 is 1 shifted by 32",
    8589934592:"Key 8589934592 is 1 shifted by 33",
    17179869184:"Key 17179869184 is 1 shifted by 34",
    34359738368:"Key 34359738368 is 1 shifted by 35",
    68719476736:"Key 68719476736 is 1 shifted by 36",
    137438953472:"Key 137438953472 is 1 shifted by 37",
    274877906944:"Key 274877906944 is 1 shifted by 38",
    549755813888:"Key 549755813888 is 1 shifted by 39",
    1099511627776:"Key 1099511627776 is 1 shifted by 40",
    2199023255552:"Key 2199023255552 is 1 shifted by 41",
    4398046511104:"Key 4398046511104 is 1 shifted by 42",
    8796093022208:"Key 8796093022208 is 1 shifted by 43",
    17592186044416:"Key 17592186044416 is 1 shifted by 44",
    35184372088832:"Key 35184372088832 is 1 shifted by 45",
    70368744177664:"Key 70368744177664 is 1 shifted by 46",
    140737488355328:"Key 140737488355328 is 1 shifted by 47",
    281474976710656:"Key 281474976710656 is 1 shifted by 48",
    562949953421312:"Key 562949953421312 is 1 shifted by 49",
    1125899906842624:"Key 1125899906842624 is 1 shifted by 50",
    2251799813685248:"Key 2251799813685248 is 1 shifted by 51",
    4503599627370496:"Key 4503599627370496 is 1 shifted by 52",
    9007199254740992:"Key 9007199254740992 is 1 shifted by 53",
    18014398509481984:"Key 18014398509481984 is 1 shifted by 54",
    36028797018963968:"Key 36028797018963968 is 1 shifted by 55",
    72057594037927936:"Key 72057594037927936 is 1 shifted by 56",
    144115188075855872:"Key 144115188075855872 is 1 shifted by 57",
    288230376151711744:"Key 288230376151711744 is 1 shifted by 58",
    576460752303423488:"Key 576460752303423488 is 1 shifted by 59",
    1152921504606846976:"Key 1152921504606846976 is 1 shifted by 60",
    2305843009213693952:"Key 2305843009213693952 is 1 shifted by 61",
    4611686018427387904:"Key 4611686018427387904 is 1 shifted by 62",
    -9223372036854775808:"Key -9223372036854775808 is 1 shifted by 63"
  ],
  Binary: h'000102030405060708090A0B0C0D0E0F1011121314151617',
  tag: 32("http://dataobjectspec.org")
}
''';
  lExpected := StringReplace(lExpected, ' ','', [rfReplaceAll]);
  lValue := StringReplace(lValue, ' ','', [rfReplaceAll]);

  Assert.AreEqual(lExpected, lValue, 'PrintToString generated different results than expected.');
end;

procedure HexStringToStream(aHexStr: string; aStream: TMemoryStream);
var
  lLen: integer;
begin
  lLen := Length(aHexStr) div 2;
  aStream.SetSize(lLen);
  HexToBin(PChar(aHexStr), aStream.Memory, lLen);
end;

procedure TestTDataObj.TestWriteToStream;
var
  lStream: TMemoryStream;
  lExpectedStream: TMemoryStream;
begin
  lStream:=TMemoryStream.create;
  lExpectedStream:=TMemoryStream.create;
  try
    FDataObj.WriteToStream(lStream);
    lStream.SaveToFile('d:\temp\S1.dataObj');

    HexStringToStream(GetTestStreamAsHex, lExpectedStream);
    lStream.seek(0,soFromBeginning);
    lExpectedStream.seek(0,soFromBeginning);

    Assert.AreEqual(lStream, lExpectedStream, 'TDataObj.WriteToStream generated different results than expected.');
  finally
    lStream.Free;
    lExpectedStream.free;
  end;
end;

procedure TestTDataObj.TestReadFromStream;
var
  lStream: TStream;
  lStream2: TStream;
begin
  lStream:=TMemoryStream.create;
  lStream2:=TMemoryStream.create;
  try
    FDataObj.WriteToStream(lStream);
    lStream.Seek(0, soFromBeginning);
    TMemoryStream(lStream).SaveToFile('d:\temp\stream1.dataobj');
    fDataObj.clear;
    FDataObj.ReadFromStream(lStream);
    FDataObj.WriteToStream(lStream2);

    Assert.AreEqual(lStream, lStream2, 'TDataObj.WriteToStream/WriteToStream did not round-trip');
  finally
    lStream.Free;
    lStream2.Free;
  end;
end;

procedure TestTDataObj.TestSettingATag;
var
  lDataObj: TDataObj;
  lSlot: TDataObj;
  lExpected: string;
  lActual: string;
begin
  lDataObj:=TDataObj.create;
  try
    lSlot := lDataObj.AsFrame.newslot('TESTSLOT');
    lSlot.AsString := 'Hello World';
    lSlot.AsTag.TagValue := 999;
    lExpected := '{ TESTSLOT: 999("Hello World")}';
    lActual := lDataObj.PrintToString;
    lActual := StringReplace(lActual, #13,'',[rfReplaceAll]);
    lActual := StringReplace(lActual, #10,'',[rfReplaceAll]);

    Assert.areEqual(lExpected, lActual,'Setting a tag did not preserve it''s previous string value');
  finally
    lDataObj.free;
  end;
end;

procedure TestTDataObj.TestDataTypeIsAContainer;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FDataObj.DataTypeIsAContainer;
  Assert.AreEqual(ReturnValue, true);
end;

procedure TestTDataObj.TestCopyFrom;
var
  lCopyDataObj: TDataObj;
  lStr1, lStr2: string;
begin
  lCopyDataObj := TDataObj.create;
  try
    lCopyDataObj.CopyFrom(fDataObj);
    lStr1 := fDataObj.PrintToString;
    lStr2 := lCopyDataObj.PrintToString;
    assert.areEqual(lStr1, lStr2, 'CopyFrom resulted in different object content');
  finally
    lCopyDataobj.free;
  end;
end;


procedure TestTDataGUID.SetUp;
begin
  FDataGUID := TDataGUID.Create;
end;

procedure TestTDataGUID.TearDown;
begin
  FDataGUID.Free;
  FDataGUID := nil;
end;

procedure TestTDataObjectID.SetUp;
begin
  FDataObjectID := TDataObjectID.Create;
end;

procedure TestTDataObjectID.TearDown;
begin
  FDataObjectID.Free;
  FDataObjectID := nil;
end;

procedure TestTDataFrame.SetUp;
begin
  FDataObj := TDataObj.Create;
  MakeTestObject(fDataObj);
  FDataFrame := fDataObj.AsFrame;
end;

procedure TestTDataFrame.TearDown;
begin
  FreeAndNil(FDataObj);
end;

procedure TestTDataFrame.TestFindSlot;
var
  lNewSlot, lSlot: TDataObj;
begin
  FDataObj.SlotnameIsCaseSensitive := false;

  lNewSlot := fDataFrame.newSlot('TESTSLOT');
  if not assigned(lNewSlot) then
    Assert.Fail('NewSlot did not return a slot object');

  lSlot := FDataFrame.FindSlot('TESTSLOT');
  if not assigned(lSlot) then
    Assert.Fail('FindSlot did not find an expected slot by a slotname (1)');

  lSlot := FDataFrame.FindSlot('testSlot');   // case insensitive compare
  if not assigned(lSlot) then
    Assert.Fail('FindSlot did not find an expected slot by a slotname (2)');

  if not FDataFrame.FindSlot('testSlot', lSlot) then   // case insensitive compare
    Assert.Fail('FindSlot did not find an expected slot by a slotname (3)');

  Assert.pass;
end;

procedure TestTDataFrame.TestNewSlot;
var
  lDataObj: TDataObj;
  lNewSlot: TDataObj;
  lFindSlot: TDataObj;
begin
  lDataObj := TDataObj.create;
  lNewSlot := lDataObj.AsFrame.newSlot('TEST');
  lFindSlot := lDataObj.AsFrame.newSlot('TEST');

  assert.AreEqual(lNewSlot, lFindSlot, 'Find Slot Did not return the expected result');
end;

procedure TestTDataFrame.TestSlotByName;
var
  lSlot: TDataObj;
  lNewSlot: TDataObj;
begin
  fDataFrame.clear;
  lNewSlot := fDataFrame.newSlot('TESTSLOT');
  if not assigned(lNewSlot) then
    Assert.Fail('NewSlot did not return a slot object');

  try
    lSlot := FDataFrame.SlotByName('ShouldNotFind');  // generates exception if not found
    if assigned(lSlot) then
      Assert.Fail('SlotByname returned an object instance, but it shouln''t have.');
    Assert.fail('SlotByName should have raised an exception but it didn''t');
  except
    // expect the exception, so trap it and all is good. and move on.
  end;

  // First, make sure that case-insensitive lookups are working.
  try
    FDataObj.SlotnameIsCaseSensitive := false;
    lSlot := FDataFrame.SlotByName('TESTSLOT');  // generates exception if not found
    if not assigned(lSlot) then
      Assert.Fail('SlotByName did not return a slot object');

    lSlot := FDataFrame.SlotByName('TestSlot');  // generates exception if not found
    if not assigned(lSlot) then
      Assert.Fail('SlotByname did not return a slot object');
  except
    on e: exception do
      Assert.Fail('Failed with exception '+e.classname+': '+e.message);
  end;

  // Now make sure that case-sensitive lookups are working only when the case matches.
  try
    FDataObj.SlotnameIsCaseSensitive := true;
    lSlot := FDataFrame.SlotByName('TESTSLOT');  // generates exception if not found
    if not assigned(lSlot) then
      Assert.Fail('SlotByname did not return a slot object');
  except
    on e: exception do
      Assert.Fail('Failed with exception '+e.classname+': '+e.message);
  end;

  try
    lSlot := FDataFrame.SlotByName('TestSlot'); // generates exception if not found, which is what we should expect.
    if assigned(lSlot) then
      Assert.Fail('SlotByname returned an object instance, but it shouln''t have.');
    Assert.fail('SlotByName should have raised an exception but it didn''t');

  except;
    // expect the exception, so trap it and all is good. and move on.
  end;

  Assert.pass;
end;

procedure TestTDataFrame.TestDeleteSlot;
var
  i: integer;
  lSlot: TDataObj;
  lStart, lEnd: TDateTime;
  lSlotName: string;
begin
  fDataFrame.clear;

  for i := 0 to 10000 do   // Making a big amount of slots so that we can test that the frame has enough slots to get over the threshold of internally making a slotname index.
  begin                    // note that if we make this 10 times bigger, then the time to do the test is 100 times more.
    fDataFrame.NewSlot('TESTSLOT'+IntToStr(i)).AsString := 'String'+IntToStr(i);
  end;

  lStart := now;
  for i := 0 to 10000 do    // do a bunch of deletes,
  begin
    if i=100 then continue;    //but, we are going to skip Number 100 and leave it in tact.

    lSlotName := 'TESTSLOT'+IntToStr(i);
    Assert.IsTrue(FDataFrame.DeleteSlot(lSlotName), 'Unable to DeleteSlot with SlotName: '+lSlotname);
  end;
  lEnd := now;
  Log('Time to delete 10,000: '+FloatToStr((lEnd-lStart)*24*60*60)+' seconds');

  // Run some asserts checking that the last remaining slot has what it should.
  Assert.areEqual(1, fDataFrame.count, 'After Deleting slots, we should be left with one slot, but the count is '+intToStr(fDataFrame.Count));
  lSlot:=fDataFrame.SlotByName('TESTSLOT100');
  Assert.IsNotNull(lSlot, 'Last remaining slot to delete was not found correctly');
  Assert.areequal('String100', lSlot.AsString, 'Last remaining slot to delete did not have the right data.');
  Assert.areequal('TESTSLOT100', fDataFrame.Slotname(0), 'Last remaining slot to delete did not have the right slotname.');
end;

procedure TestTDataFrame.TestDelete;
var
  i: integer;
  lIndex: Integer;
  lSlot: TDataObj;
  lStart, lEnd: TDateTime;
begin
  fDataFrame.clear;

  for i := 0 to 10000 do   // Making a big amount of slots so that we can test that the frame has enough slots to get over the threshold of internally making a slotname index.
  begin                    // note that if we make this 10 times bigger, then the time to do the test is 100 times more.
    fDataFrame.NewSlot('TESTSLOT'+IntToStr(i)).AsString := 'String'+IntToStr(i);
  end;

  lStart := now;
  for i := 0 to 10000 do    // do a bunch of deletes,
  begin
    if i=100 then continue;    //but, we are going to skip Number 100 and leave it in tact.

    lSlot:=fDataFrame.SlotByName('TESTSLOT'+IntToStr(i));
    lIndex := fDataFrame.IndexOfChildSlot(lSlot);
    Assert.IsTrue(FDataFrame.Delete(lIndex), 'Unable to Delete Slot with index: '+InttoStr(lIndex));
  end;
  lEnd := now;
  Log('Time to delete 10,000: '+FloatToStr((lEnd-lStart)*24*60*60)+' seconds');

  // Run some asserts checking that the last remaining slot has what it should.
  Assert.areEqual(1, fDataFrame.count, 'After Deleting slots, we should be left with one slot, but the count is '+intToStr(fDataFrame.Count));
  lSlot:=fDataFrame.SlotByName('TESTSLOT100');
  Assert.IsNotNull(lSlot, 'Last remaining slot to delete was not found correctly');
  Assert.areequal('String100', lSlot.AsString, 'Last remaining slot to delete did not have the right data.');
  Assert.areequal('TESTSLOT100', fDataFrame.Slotname(0), 'Last remaining slot to delete did not have the right slotname.');
end;

procedure TestTDataFrame.TestSlotname;
var
  lSlotName: string;
  lSlot: TDataObj;
  lIndex: integer;
begin
  lSlot:=fDataFrame.NewSlot('TESTSLOT');
  if not assigned(lSlot) then
    Assert.fail('Calling NewSlot did not result in the returning of an object instance.');
  lSlot:=fDataFrame.NewSlot('testslot');   // doing it again with a different case, but it should "find" the upper case version.
  lIndex := fDataFrame.IndexOfChildSlot(lSlot);
  lSlotName := FDataFrame.Slotname(lIndex);
  Assert.AreEqual('TESTSLOT', lSlotName, 'Slotname did not match what was expected.');
end;

procedure TestTDataFrame.TestCount;
begin
  Assert.AreEqual(20,FDataFrame.Count, 'Count did not return the expected value');
end;

procedure TestTDataFrame.TestCaseSensitive;
var
  lSlot: TDataObj;
begin
  fDataObj.SlotNameIsCaseSensitive := true;
  Assert.IsTrue(fDataObj.AsFrame.FindSlot('String', lSlot), 'In a Frame, finding "String" should have been found when CaseSensitive is true.');
  Assert.IsFalse(fDataObj.AsFrame.FindSlot('string', lSlot), 'In a Frame, finding "string" should not be found when CaseSensitive is true, but it was found.');

  fDataObj.SlotNameIsCaseSensitive := false;
  Assert.IsTrue(fDataObj.AsFrame.FindSlot('String', lSlot), 'In a Frame, finding "String" should have been found when CaseSensitive is false.');
  Assert.IsTrue(fDataObj.AsFrame.FindSlot('string', lSlot), 'In a Frame, finding "string" should have been found when CaseSensitive is false.');

  gSlotNameIndexThreshold := cDefaultSlotNameIndexThreshold;  // restore to default.
end;

procedure TestTDataFrame.TestClear;
begin
  FDataFrame.Clear;
  Assert.isTrue(fDataObj.AsFrame.count=0, 'Clear did not clear everything in the frame.');
end;

procedure TestTDataFrame.TestCopyFrom;
var
  lObj: TDataObj;
  lObj2: TDataObj;
begin
  lObj:=TDataObj.Create;
  lObj2:=TDataObj.Create;
  try
    MakeTestObject(lObj);
    lObj2.CopyFrom(lObj);
    Assert.areEqual(lObj.PrintToString, lObj2.PrintToString,'TDataobj.CopyFrom did not create an exact copy.');
  finally
    lObj.Free;
    lObj2.Free;
  end;
end;

procedure TestTDataArray.SetUp;
begin
  fDataobj := TDataObj.create;
  FDataArray := fDataObj.AsArray;
end;

procedure TestTDataArray.TearDown;
begin
  fDataobj.Free;
  fDataobj := nil;
end;

procedure TestTDataArray.TestNewSlot;
var
  i: integer;
  lCountBefore: integer;
  lCountAfter: integer;
begin
  for i := 0 to 1000 do
  begin
    lCountBefore := fDataArray.Count;
    fDataArray.newSlot.Asint32 := Random(10000);
    lCountAfter := fDataArray.count;
    if lCountAfter <> lCountBefore+1 then
    begin
      Assert.Fail('Calling NewSlot did not increase the count of the array');
      exit;
    end;
  end;
  Assert.Pass('');
end;

procedure TestTDataArray.TestFind;
var
  i: integer;
  lfoundObj: TDataObj;
begin
  // Build an array that we can use to test with.
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.Asint32 := i;
  end;

  lFoundObj := fDataArray.find(
    function(aArray: TDataArray; aCurrentObj: TDataObj; aIndex: integer): boolean
    begin
      result := aCurrentObj.AsString = '999';
    end
  );

  if not assigned(lFoundObj) then
    Assert.fail('Find call did not return a slot that was expected to be found.');

  lFoundObj := fDataArray.find(
    function(aArray: TDataArray; aCurrentObj: TDataObj; aIndex: integer): boolean
    begin
      result := aCurrentObj.AsString = 'abcd123';
    end
  );

  if assigned(lFoundObj) then
    Assert.fail('Find call did not returned an object that should not have been found.');

  Assert.pass;
end;

procedure TestTDataArray.TestForEach;
var
  i: integer;

  procedure DoTheTest(aReverse: boolean);
  var
    lCount: integer;
  begin
    lCount := 0;
    fDataArray.ForEach(
      procedure(aArray: TDataArray; aCurrentValue: TDataObj; aIndex: integer)
      begin
        if aArray.Slots[aIndex] <> aCurrentValue then
          Assert.Fail('Parameters called into ForEach callback did not match each other as expected. aReverse='+BoolToStr(aReverse));

        if aCurrentValue.AsInt32 <> aIndex then
          Assert.Fail('Array item value did not match its expected index. aReverse='+BoolToStr(aReverse));

        inc(lCount);
      end, aReverse
    );

    Assert.AreEqual(fDataArray.count, lCount, 'Count of items in an array did not match the iteration call count of ForEach. aReverse='+BoolToStr(aReverse));
  end;
begin
  // Build an array that we can use to test with.
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.Asint32 := i;
  end;

  DoTheTest(false);
  DoTheTest(true);
end;

procedure TestTDataArray.TestEvery;
var
  i: integer;
  lCount: integer;
begin
  // Build an array that we can use to test with.
  fDataArray.clear;
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.Asint32 := i;
  end;

  // First, run the test expected all items to be truthy
  lCount := 0;
  Assert.AreEqual(true, fDataArray.Every(
    function(aArray: TDataArray; aCurrentValue: TDataObj; aIndex: integer): boolean    // should return true for every item that is truthy
    begin
      if aArray.Slots[aIndex] <> aCurrentValue then
        Assert.Fail('Parameters called into ForEach callback did not match each other as expected.');

      result := aCurrentValue.AsInt32 = aIndex;

      inc(lCount);
    end
  ),'When all items in the Every call should be true');

  Assert.AreEqual(fDataArray.count, lCount, 'Count of items in an array did not match the iteration call count of Every.');

  // Second, run the test expecting one of the items to not be truthy
  lCount := 0;
  fDataArray.items[1000].AsInt32 := -1;     // Make of the items not be truthy
  Assert.AreEqual(false, fDataArray.Every(
    function(aArray: TDataArray; aCurrentValue: TDataObj; aIndex: integer): boolean    // should return true for every item that is truthy
    begin
      if aArray.Slots[aIndex] <> aCurrentValue then
        Assert.Fail('Parameters called into ForEach callback did not match each other as expected.');

      result := aCurrentValue.AsInt32 = aIndex;

      inc(lCount);
    end
  ),'When one of the items in the Every call should be false');

  Assert.AreEqual(fDataArray.count, lCount, 'Count of items in an array did not match the iteration call count of Every.');

end;

procedure TestTDataArray.TestIndexOf;
var
  i: integer;
  lStrVal: string;
begin
  // Build an array that we can use to test with.
  fDataArray.clear;
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.Asint32 := i;
  end;

  if 987 <> fDataArray.IndexOf(987) then     //Int32
    Assert.fail('Indexof for value 987 expected to return an index of 987');

  if 987 <> fDataArray.IndexOf('987') then   // String comparison
    Assert.fail('Indexof for value 987 expected to return an index of 987');

  // Build a new array that we can use to test with using 64 bit ints.
  fDataArray.clear;
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.Asint64 := Int64(i)+int64($100000000);
  end;

  if 987 <> fDataArray.IndexOf(int64(987)+int64($100000000)) then     //Int64 comparison
    Assert.fail('Indexof for value 987 expected to return an index of 987');

  lStrVal := IntToStr(int64(987)+int64($100000000));
  if 987 <> fDataArray.IndexOf(lStrVal) then                       // String comparison
    Assert.fail('Indexof for value '+lStrVal+' expected to return an index of 987');


  // now add a string to the end of the array and try to test indexOf on that.
  fDataArray.newSlot.AsString := '987654321';
  if 1001 <> fDataArray.Indexof(987654321) then
    Assert.fail('Indexof for integer value 987654321 could not find string value "987654321"');

  if 1001 <> fDataArray.Indexof(987654321) then
    Assert.fail('Indexof for string value "987654321" could not find string value "987654321"');

  Assert.pass('All IndexOf variations passed.');
end;

procedure TestTDataArray.TestLastIndexOf;
var
  i: integer;
begin
  // Build an array that we can use to test with.
  fDataArray.clear;
  fDataArray.newSlot.AsString := '999';
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.AsInt32 := i;   // yes.  as Integer, but LastIndex of below is string.
  end;

  if fDataArray.LastIndexOf('') <> -1 then
    Assert.Fail('LastIndexOf should have returned a -1 for a non-found value');

  Assert.AreEqual(1000,fDataArray.LastIndexOf('999'), 'Last IndexOf "999" did not return the expected index');
end;

procedure TestTDataArray.TestRemoveForEach;
var
  i: integer;
begin
  // Build an array that we can use to test with.
  fDataArray.clear;
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.AsInt32 := i;
  end;

  fDataArray.RemoveForEach(
    function(aArray: TDataArray; aCurrentValue: TDataObj; aIndex: integer): boolean
    begin
      result := (aCurrentValue.AsInt32 mod 2) = 0;   // remove all the even items.
    end
  );

  Assert.AreEqual(500,fDAtaArray.count, 'Incorrect number of removals in a RemoveForEach call');
end;

procedure TestTDataArray.TestReduce;
var
  i: integer;
  lReducedObject: TDataObj;
  lSum: int64;
begin
  // Build an array that we can use to test with.
  fDataArray.clear;
  lSum := 0;
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.AsInt32 := i;
    inc(lSum, i);
  end;

  lReducedObject := fDataArray.Reduce(
    procedure(aTotal: TDataObj; aArray: TDataArray; aCurrentObj: TDataObj; aIndex: integer)
    begin
      aTotal.AsInt64 := aTotal.AsInt64+aCurrentObj.AsInt64;
    end
  );
  try
    Assert.areEqual(lSum, lReducedObject.AsInt64);
  finally
    lReducedObject.free;
  end;
end;

procedure TestTDataArray.TestMap;
var
  i: integer;
  lNewMappedObject: TDataObj;
begin
  // Build an array that we can use to test with.
  fDataArray.clear;
  for i := 0 to 1000 do
  begin
    fDataArray.newSlot.AsInt32 := i;   // Yes.  as Integer, but LastIndex of below is string.
  end;

  lNewMappedObject := fDataArray.map(
    procedure(aTargetObj: TDataObj; aCurrentArray: TDataArray; aCurrentObj: TDataObj; aIndex: integer)
    begin
      aTargetObj.AsString := aCurrentObj.AsString;   // convert from Ints to string.
    end
  );
  try
    if lNewMappedObject.AsArray.count <> fDataArray.count then
    begin
      assert.fail('Map call on an array object returned a count that differed from the original.');
    end;

    // Compare the source to the mapped object
    for i := 0 to lNewMappedObject.AsArray.count-1 do
    begin
      if (lNewMappedObject.asArray[i].AsString <> fDAtaArray[i].AsString) then
        assert.fail('Value in an item from a Map call did not have the expected value at index '+IntToStr(i));
    end;
    Assert.pass;
  finally
    lNewMappedObject.free;
  end;
end;

procedure TestTDataArray.TestConcat;
var
  i: integer;
  lSum: integer;
  lAppendFrom: TDataObj;
  lCheckSum: integer;
  lConcatArray: TDataObj;
begin
  // Build two arrays that we can use to test with.
  lAppendFrom:=TDataObj.create;
  try
    fDataArray.clear;
    lSum:=0;
    for i := 0 to 1000 do
    begin
      fDataArray.newSlot.AsInt32 := i;
      lAppendFrom.AsArray.newSlot.Asint32 := i;
      inc(lSum, i);
    end;

    lConcatArray:=fDataArray.Concat(lAppendFrom.AsArray);
    try
      // now check that we have double the sum
      lCheckSum := 0;
      for i := 0 to lConcatArray.AsArray.count-1 do
      begin
        inc(lCheckSum, lConcatArray.AsArray[i].Asint32);
      end;

      Assert.AreEqual(lSum*2, lCheckSum, 'Concat didn''t get all the data copied.');
    finally
      lConcatArray.free;
    end;
  finally
    lAppendFrom.free;
  end;
end;

procedure TestTDataArray.TestAppendFrom;
var
  i: integer;
  lSum: integer;
  lAppendFrom: TDataObj;
  lCheckSum: integer;
begin
  // Build two arrays that we can use to test with.
  lAppendFrom:=TDataObj.create;
  try
    fDataArray.clear;
    lSum:=0;
    for i := 0 to 1000 do
    begin
      fDataArray.newSlot.AsInt32 := i;
      lAppendFrom.AsArray.newSlot.Asint32 := i;
      inc(lSum, i);
    end;

    fDataArray.AppendFrom(lAppendFrom.AsArray);

    // now check that we have double the sum
    lCheckSum := 0;
    for i := 0 to fDataArray.count-1 do
    begin
      inc(lCheckSum, fDataArray.slots[i].Asint32);
    end;

    Assert.AreEqual(lSum*2, lCheckSum, 'AppendFrom didn''t get all the slots copied.');
  finally
    lAppendFrom.free;
  end;
end;

procedure TestTDataSparseArray.SetUp;
var
  lVal: int64;
begin
  fDataObj := TDataObj.create;
  FSparseArray := fDataObj.AsSparseArray;
  for lVal in cTestSet do
  begin
    FSparseArray.NewSlot(lVal,true).AsInt64 := lVal;
  end;
end;

procedure TestTDataSparseArray.TearDown;
begin
  fDataObj.Free;
  fDataObj := nil;
end;

procedure TestTDataSparseArray.TestFindSlot;
var
  lVal: int64;

  procedure DoTest(aIndex: int64);
  var
    lSlot: TDataObj;
  begin
    lSlot := FSparseArray.FindSlot(aIndex);
    Assert.IsNotNull(lSlot, 'Unable to lookup index '+IntToStr(aIndex)+' in sparse Array');
    if assigned(lSlot) then
      Assert.AreEqual(lSlot.AsInt64, aIndex, 'Value retrieved of '+IntToStr(lSlot.AsInt64) +' did not match expected value of '+IntToStr(aIndex));
  end;
begin
  for lVal in cTestSet do
  begin
    DoTest(lVal);
  end;
end;

procedure TestTDataSparseArray.TestNewSlot;
var
  ReturnValue: TDataObj;
begin
  ReturnValue := FSparseArray.NewSlot(-99, true);
  assert.IsNotNull(ReturnValue, 'Calling NewSlot did not return a new object');
end;


procedure TestTDataSparseArray.TestSlotByIndex;
var
  lVal: int64;

  procedure DoTest(aIndex: int64);
  var
    lSlot: TDataObj;
  begin
    lSlot := FSparseArray.SlotByIndex(aIndex);
    Assert.IsNotNull(lSlot, 'Unable to lookup index '+IntToStr(aIndex)+' in sparse Array');
    if assigned(lSlot) then
      Assert.AreEqual(lSlot.AsInt64, aIndex, 'Value retrieved of '+IntToStr(lSlot.AsInt64) +' did not match expected value of '+IntToStr(aIndex));
  end;

begin
  for lVal in cTestSet do
  begin
    DoTest(lVal);
  end;
end;

procedure TestTDataSparseArray.TestDeleteSlot;
var
  lVal: int64;
  procedure DoTest(aInt64: int64);
  begin
    FSparseArray.DeleteSlot(aInt64);
  end;
begin
  for lVal in cTestSet do
  begin
    DoTest(lVal);
  end;

  Assert.AreEqual(fSparseArray.count, 0, 'Deleting all test slots by SlotIndex failed to delete all slots in the test sparse array.');
end;

procedure TestTDataSparseArray.TestSlotIndex;
var
  lVal: Int64;
  lCount: integer;

  procedure DoTest(aIndex: integer; aValue: int64);
  begin
    Assert.AreEqual(FSparseArray.SlotIndex(aIndex), aValue, 'SlotIndex returned an unexpected value');
  end;
begin
  lCount := 0;
  for lVal in cTestSet do
  begin
    DoTest(lCount,lVal);
    inc(lCount);
  end;
end;

procedure TestTDataSparseArray.TestClear;
begin
  FSparseArray.Clear;
  Assert.areEqual(0,fSparseArray.count, 'Test Clear did not fully clear the SparseArray');
end;

procedure TestTDataSparseArray.TestCopyFrom;
var
  aCopyDataObj: TDataObj;
  lMain: string;
  lCopy: string;
begin
  aCopyDataObj := TDataObj.create;
  try
    aCopyDataObj.AsSparseArray.copyFrom(fSparseArray);
    lMain := FDataObj.PrintToString;
    lCopy := FDataObj.PrintToString;
    assert.AreEqual(lMain, lCopy, 'SparseArray.CopyFrom failed to preserve exact data.');
  finally
    aCopyDataObj.free;
  end;
end;



{ TestVarInts }

procedure TestVarInts.TestVarInt32;
  procedure DoTest(aInt: Int32);
  var
    lInt2: Int32;
    lUInt: UInt32;
  begin
    lUInt := TVarInt32.ZigZagEncode32(aInt);
    lInt2 := TVarInt32.ZigZagDecode32(lUInt);
    Assert.AreEqual(aInt, lInt2, IntToStr(aInt)+' Roundtrip to zigzag and back failed. returned as '+IntToStr(lInt2));
  end;
begin
  DoTest(0);
  DoTest(1);
  DoTest(2);
  DoTest(3);
  DoTest(-1);
  DoTest(Int32($7fffffff));
  DoTest(Int32($80000000));
  DoTest(Int32($ffffffff));
  DoTest(Int32($ffffffff));
end;

procedure TestVarInts.TestVarInt64;
  procedure DoTest(aInt: Int64);
  var
    lInt2: Int64;
    lUInt: UInt64;
  begin
    lUInt := TVarInt64.ZigZagEncode64(aInt);
    lInt2 := TVarInt64.ZigZagDecode64(lUInt);
    Assert.AreEqual(aInt, lInt2, IntToStr(aInt)+' Roundtrip to zigzag and back failed. returned as '+IntToStr(lInt2));
  end;
begin
  DoTest(0);
  DoTest(1);
  DoTest(2);
  DoTest(3);
  DoTest(-1);
  DoTest(Int64($7fffffffffffffff));
  DoTest(Int64($8000000000000000));
  DoTest(Int64($ffffffffffffffff));
  DoTest(Int64($fffffffffffffffe));
end;

{ TestUnicodeCompareText }

procedure TestUnicodeCompareText.SetUp;
begin
  inherited;

end;

procedure TestUnicodeCompareText.TearDown;
begin
  inherited;

end;

procedure TestUnicodeCompareText.TestCompareText;

  procedure RunUnicodeCasePairs;
  var
    k: integer;
    Code: Integer;
    lChar: char;
    lTestString: string;
    lUpperStr, lLowerStr: string;
    lCharCount: integer;
    lTestCounter: integer;

    lResultLower: Integer;
    lWinResultLower: integer;
    lResultUpper: Integer;
    lWinResultUpper: integer;

    lDiffCount: integer;
    lIsDiff: boolean;
    lStart, lEnd: TDatetime;
    lTestStrings: array of string;
    lTestStringsUpper: array of string;
    lCounter: integer;

    function ToUpperString(const S: string): string;
    var
      Buffer: array of WideChar;
    begin
      // Allocate buffer with null terminator
      SetLength(Buffer, Length(S) + 1);
      if S <> '' then
        Move(PChar(S)^, Buffer[0], Length(S) * SizeOf(WideChar));
      Buffer[Length(S)] := #0;

      // Call Windows API to uppercase in-place
      CharUpperW(@Buffer[0]);

      // Return result as Delphi string
      SetString(Result, PWideChar(@Buffer[0]), Length(S));
    end;

    function ToLowerString(const S: string): string;
    var
      Buffer: array of WideChar;
    begin
      // Allocate buffer with null terminator
      SetLength(Buffer, Length(S) + 1);
      if S <> '' then
        Move(PChar(S)^, Buffer[0], Length(S) * SizeOf(WideChar));
      Buffer[Length(S)] := #0;

      // Call Windows API to lowercase in-place
      CharLowerW(@Buffer[0]);

      // Return result as Delphi string
      SetString(Result, PWideChar(@Buffer[0]), Length(S));
    end;

    function WindowsCompareUnicodeInsensitive(const S1, S2: string): Integer;
    begin
      Result := CompareStringW(
        LOCALE_USER_DEFAULT,         // or LOCALE_INVARIANT for consistent behavior
        NORM_IGNORECASE,             // case-insensitive flag
        PWideChar(S1), Length(S1),
        PWideChar(S2), Length(S2)
      );

      // Normalize return value to -1, 0, 1
      case Result of
        CSTR_LESS_THAN:    Result := -1;
        CSTR_EQUAL:        Result := 0;
        CSTR_GREATER_THAN: Result := 1;
      else
        raise Exception.Create('CompareStringW failed');
      end;
    end;


  begin
    lTestCounter := 0;
    for lCharCount := 1 to 5 do
    begin
      for Code := 0 to $FFFF do
      begin
        lChar := Char(Code);
        lTestString := StringOfChar(lChar, lCharCount);
        lUpperStr := ToUpperString(lTestString);
        lLowerStr := ToLowerString(lTestSTring);

        lIsDiff := false;
        if (lTestString<>lUpperStr) or (lTestString<>lLowerStr) then
        begin
          inc(lDiffCount);
          lIsDiff := true;
        end;

        lResultLower := CompareTextUnicode(lTestString, lLowerStr);
        lWinResultLower := WindowsCompareUnicodeInsensitive(lTestString, lLowerStr);
        lResultUpper := CompareTextUnicode(lTestString, lUpperStr);
        lWinResultUpper := WindowsCompareUnicodeInsensitive(lTestString, lUpperStr);

        if lResultLower <> lWinResultLower then
        begin
          Assert.fail('Comparing '+lTestString+' and '+lLowerStr+' Failed with result = '+IntToStr(lResultLower));
        end;

        if lResultUpper <> lWinResultUpper then
        begin
          Assert.fail('Comparing '+lTestString+' and '+lUpperStr+' Failed with result = '+IntToStr(lResultUpper));
        end;

        lResultLower := CompareTextUnicode(lLowerStr, lTestString);
        lWinResultLower := WindowsCompareUnicodeInsensitive(lLowerStr, lTestString);
        lResultUpper := CompareTextUnicode(lUpperStr, lTestString);
        lWinResultUpper := WindowsCompareUnicodeInsensitive(lUpperStr, lTestString);

        if lResultLower <> lWinResultLower then
        begin
          Assert.fail('Comparing '+lLowerStr+' and '+lTestString+' Failed with result = '+IntToStr(lResultLower));
        end;
        if lResultUpper <> lWinResultUpper then
        begin
          Assert.fail('Comparing '+lUpperStr+' and '+lTestString+' Failed with result = '+IntToStr(lResultUpper));
        end;

        if lResultLower <> 0 then
        begin
          Assert.fail('Comparing '+lLowerStr+' and '+lTestString+' Failed with result = '+IntToStr(lResultLower));
        end;

        if lResultUpper <> 0 then
        begin
          Assert.fail('Comparing '+lUpperStr+' and '+lTestString+' Failed with result = '+IntToStr(lResultUpper));
        end;

(*        if lIsDiff then
        begin
          log(lTestString+' : '+ lUpperStr +' : '+ lLowerStr+ ' : '+IntToHex(Code));
        end;
        *)

        inc(lTestCounter);
      end;
    end;
    // Here is a little speed test comparing the windows version with the CompareTextUnicode version.
    // First, make the strings so that part is not within our timing
    // We are picking a size of 15 which is on the higher end of the size of a slotname
    SetLength(lTestStrings, $FFFF+1);
    SetLength(lTestStringsUpper, $FFFF+1);
    for Code := 0 to $FFFF do
    begin
      lChar := Char(Code);
      lTestStrings[code] := StringOfChar(lChar, 15);
      lTestStringsUpper[code] := ToUpperString(lTestStrings[code]);
    end;



    lStart := now;
    for k := 0 to 10 do
    begin
      lCounter := 0;
      for Code := 0 to $FFFF do
      begin
        if WindowsCompareUnicodeInsensitive(lTestStrings[code], lTestStringsUpper[code])=0 then
          inc(lCounter);
      end;
    end;
    lEnd := now;
    log('Windows Time: '+FloatToStrF((lEnd-lStart)*24*60*60,ffFixed, 3,3)+', MatchCount='+IntToStr(lCounter));

    lStart := now;
    for k := 0 to 10 do
    begin
      lCounter := 0;
      for Code := 0 to $FFFF do
      begin
        if CompareTextUnicode(lTestStrings[code], lTestStringsUpper[code])=0 then
          inc(lCounter);
      end;
    end;
    lEnd := now;
    log('CompareTextUnicode Time: '+FloatToStrF((lEnd-lStart)*24*60*60,ffFixed, 3,3)+', MatchCount='+IntToStr(lCounter));

    lStart := now;
    for k := 0 to 10 do
    begin
      lCounter := 0;
      for Code := 0 to $FFFF do
      begin
        if CompareText(lTestStrings[code], lTestStringsUpper[code])=0 then
          inc(lcounter);
      end;
    end;
    lEnd := now;
    log('CompareText Time: '+FloatToStrF((lEnd-lStart)*24*60*60,ffFixed, 3,3)+', MatchCount='+IntToStr(lCounter));


    Assert.pass('Ran '+IntToStr(lTestCounter)+' CompareTextUnicode() tests and they all passed with a diff count of '+IntToStr(lDiffCount));
  end;

begin
  RunUnicodeCasePairs

end;

initialization
  // Register any test cases with the test runner
  TDUnitX.RegisterTestFixture(TestTDataObj);
  TDUnitX.RegisterTestFixture(TestTDataGUID);
  TDUnitX.RegisterTestFixture(TestTDataObjectID);
  TDUnitX.RegisterTestFixture(TestTDataFrame);
  TDUnitX.RegisterTestFixture(TestTDataArray);
  TDUnitX.RegisterTestFixture(TestTDataSparseArray);
  TDUnitX.RegisterTestFixture(TestVarInts);

  TDUnitX.RegisterTestFixture(TestUnicodeCompareText);
end.

